#!/usr/bin/env perl
############################################################
#
# $Id: network-interactions ,v 0.1 2020/06/12 mpadilla Exp $
#
############################################################


=pod

=head1 NAME

network-interactions

=head1 VERSION

version 1

=head1 DESCRIPTION

Constructs Gene Networks based on the output of <matrix-scan> from a list
of genes and transcriptional factors of interest.

=head1 AUTHORS

mpadilla@lcgej.unam.mx
amedina@liigh.unam.mx

=head1 CATEGORY

=over

=item network tool

=back

=head1 USAGE

network-interactions -tfs [TFsListFile] -cre [RegulatorySeqsBEDfile] -genome [GenomeAssembly] [...]

=head1 INPUT FORMATS

=head2 TFs list file

A one-column file with all transcriptional factors of interest.
Warning! This names should match the gene names indicated in the BED file.

=head2 Regulatory regions BED file

A BED file referring all regulatory regions of all genes of interest,
including TFs. Gene names must be provided in the fourth column.

=head2 Network file

A two-column file indicating all two-node interactions, one per row.

=head1 OUTPUT FORMATS

=head2 Complete Network. <complete_direct_interactions_date.tsv>

A table indicating all direct putative interactions found for all genes
specified in the BED file of regulatory regions. Format is as follows: A
TF-gene interaction per row, the coordinates in which the interaction was
found (as indicated in the input BED), the one-based position starting from
the first coordinate followed at last by the <matrix-scan>'s related score
to the TF's binding in such position. If the interaction is found more than
once, then details of positions and scores are separated by ";", where the
first score corresponds to the first position and so on. If the interaction
is found in another coordinate, then this will appear on another row.

=head2 Gene Regulatory Network. <GRN_direct_interactions_date.tsv>

A table indicating all direct putative interactions found only for
transcription factors. Format is as follows: A TF-TF interaction per row
(the first one regulates the second one), the coordinates in which the
interaction was found, the one-based position starting from the first
coordinate followed at last by the <matrix-scan>'s related score to the TF's
binding in such position. If the interaction is found more than once, then
details of positions and scores are separated by ";", where the first score
corresponds to the first position and so on. If the interaction is found in
another coordinate, then this will appear on another row.

=head2 Gene Regulatory Network indirect interactions. <GRN_indirect_interactions_date.tsv>

Because the program only finds direct putative interactions, this file
indicates all direct interactions composed by 3 nodes. E.g.:
       TFx ==> TFy ==> TFz
which should be read as: TFx directly regulates TFy and TFy directly
regulates TFz, thus, TFx indirectly regulates TFz.

Special cases:

A TF has no targets.
  If a TF has no direct targets (hence no indirect targets) it is specified
  as: "TFx has no targets". If this given "TFx" is a direct target of
  another TF, then "TFx" will simply be a terminal node.

TF regulating itself.
  Cases of TFs putatively regulating theirselves are only specified once,
  as a two-node interaction. E.g.:    TFy ==> TFy

For each TF-TF interaction, the same details are given as in
<GRN_direct_interactions_date.tsv>, these are: coordinates, positions and
scores.

=head2 Network Comparision (-report_net)

When an input network is given, a comparision is made between the input
network and the one generated by the program (the complete network), notice
that this comparison is made only for the direct interactions found. This
comparision is made only taking into account all genes refered to in the
input BED file and will generate the three following output files:

=head2 network_intersection_date.tsv

A tab-delimited file containing, one per row, all the common interactions
between the input network and the network of all genes generated by the
program. Information about coordinates, positions and scores related to the
output network is also given.

=head2 network_rejected_interactions_date.tsv

A two-column, tab-delimited file containing, one per row, all the
interactions found in the input network but not found again in the output
network (the assymetric difference for input network).

An interaction can be "rejected" for one of several reasons:
 a) One or both of the gene's regulatory sequence was not indicated.
 b) The chosen motif database does not contain a matrix describing the
    motif for the TF in the interaction. Default database is JASPAR's 2020
    nonredundant vertebrate motif collection.
 c) <matrix-scan> did not found an instance of the TF's motif in the genomic
    sequences indicated or it found it but it was not reliable given the
    score and/or p-val thresholds.

Since these interactions are absent in the complete output network,
information about coordinates, positions and scores are also absent.


=head2 network_found_interactions_date.tsv

A tab-delimited file containing, one per row, all the interactions found by
the program but that were not specified in the input network (the assymetric
difference for the complete network). Information about coordinates, positions
and scores related to the output network is also given.


=head1 SEE ALSO

=head1 WISH LIST

=over

=item B<wish 1>

=item B<wish 2>

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}

require "RSA.lib";
#use strict;
use warnings;
use Cwd;

################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.48 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  #our %infile = ();
  #our %outfile = ();

  our $verbose = 1;
  our $in = \*STDIN;
  my $out = \*STDOUT;

  # command-line arguments
  %main::infile = ();
  %main::outfile = (); # hash of main output files
  %main::used_outfile = (); # hash of intermediate files used by the program
  our $databases = ""; # matrixes dbs
  our $genome = ""; # working genome version
  our $orgdb = ""; # alternative to databases
  our $report_net = 0; # boolean, 1 if network is provided
  #our $net_type = "not_grn"; # default for network type
  our $title = "network interactions results"; # tilte for summary html page
  our $html = 0; # flag variable to output html or not
  our $date = ""; # date for output files
  our $output_prefix = "";
  our $output_dir = "";
  our $seq = 0; # flag variable for input sequences
  our $matrices = 0; # flag variable for input matrices
  our $scan = 0; # flag variable for input scan
  our $score = 5; # score lth to run matrix-scan
  our $pval = "NA"; # pval lth to run matrix-scan
  our $archive_format = "zip";

  # tables strings for html page
  %main::tables_str = ();

  my $basename = "";
  local $log; # filehandle for log file

  # other variables
  my $new_enhancer; # filehandle of filtered bed file
  my @genes_reg = (); # genes regulated
  my %nonRep_genes_reg; # hash of non-repetitive genes regulated
  my $val = 0; # values of has %nonRep_genes_reg
  my $i; # general counter variable

  my %nonRepTFs; # hash of non repetitive TFs
  my $report_tfs_noRegSeq = ""; # string with TFs not found on bed file
  my $report_tfs_RegSeq = ""; # string with TFs found on bed file

  my (@net_old_allgenes, @net_old_onlyTFs); # networks from input
  my %noRegSeq = (); # genes lacking regulatory sequence
  my $noRegSeq_reporting = ""; # string of genes lacking reg seq
  my %RegSeq = (); # genes with regulatory sequence on input
  my $RegSeq_reporting = ""; # string of genes with reg seq
  my $z = 0; # values of a hash
  my $flag = 0;
  my $ngenes = 0; # number of genes regulated
  my $ntfs = 0; # number of genes regulated

  my @matfiles_path = (); # rsat path to matrixes in use
  my @dbs = ();  # list of databases
  my @fields = (); # general var, list of fields from rows in a file
  my @nonRepTFs_k; # TFs list
  my $fasta; # filehandle of sequences
  my $new_fasta; # filehandle of sequences with headers
  my $cmd = ""; # general variable for &doit
  my $ACs = ""; # list of ACs from matrixes to use

  my (@net_new_allgenes, @net_new_onlyTFs); # networks
  my @seq_id; # seq_id splitted from matrix-scan results
  my %interaction_details;
  my @gene_name = ();
  my @deadend = (); # binary list with length of total TFs, 1 if the TF has no direct interactions
  my $matrixscan_re; # filehandle of matrix-scan results

  my $interaction_gene_row; # complete network filehandle
  my ($intersection, $found, $rejected); # filehandles for networks' intersection and complements

  my $count = 0;
  my %nonRepTFs_inv; # inverse hash of nonRepTFs

  my $direct; # filehandle of file with GRN direct interactions (main output)
  my $path = ""; # construction of paths in node

  ## Parameters for the &doit() command
  $dry = 0;
  $die_on_error = 1;
  $job_prefix = "network-interactions";
  $batch = 0;
  #$main::archive=0; # used only once

  $main::out = STDOUT; # one_command() relies on this variable

#if ( $html == 1 )
  #local @tab_to_convert = (); ## Tables to convert to html

  ## A hash to save the name of the clusters and their corresponding
  ## hexa code
  #local %hexa_code = (); # used only once
  local $blue_color = '#D6EEFA';
  local $orange_color = '#F6E6CA';
  local $font_color = '#CC6600';
  local $blue_font_color = '#0D73A7';

  ## Hash containing the icon paths
  local %icons = ();
  my $icons_path = $ENV{RSAT}."/public_html/images/program_icons/network-interactions_icons/";
  $icons{network} = $icons_path."network.png";
  $icons{indirect} = $icons_path."indirect.png";
  $icons{comparision} = $icons_path."comparision.png";

  local $include_js_lib = 1;

  ## Base on which we will buld the the URLs to the javascripts (D3 +
  ## JQuery libraries, required to display logo trees and tables).
  local $js_base;
  local $d3_base;
  local $d3_venn_base;
  local $jquery_base;
  local $datatable_base;
  local $datatable_css_base;


  ################################################################
  ## Read argument values
  &ReadArguments();

  ## set date for output and report
  $date = &AlphaDate() if ( $date eq "");

 ################################################################
  ## Check argument values
  unless ($main::infile{TFs}) {
    &RSAT::error::FatalError("File with the network's transcription factors must be provided\n It must be a one-column file with list of TFs");
  }
  unless ($main::infile{cres}) {
    &RSAT::error::FatalError("Bed file of enhancer sequences must be provided\n On the 4th column the gene it is referring to must be specified");
  }
  unless ($main::genome) {
    &RSAT::error::FatalError("Genome version must be specified with option -genome (e.g. mm9, hg19)");
  }
  if($report_net){
    unless ($main::infile{network}) {
      &RSAT::error::FatalError("Turned on network reporting (-rep_net) but no network (-net) provided");
    }
  }
  if ($main::output_dir eq "") {
    $main::output_dir = "network-interactions_".$date;
  }
  &RSAT::util::CheckOutDir($main::output_dir);

  #################################################################
  ## Test for CGI
  if ((defined($ENV{RSA_OUTPUT_CONTEXT})) &&
      (($ENV{RSA_OUTPUT_CONTEXT}eq "cgi") || ($ENV{RSA_OUTPUT_CONTEXT} eq "RSATWS"))) {
      $_ =~ s|$ENV{RSAT}/public_html/|$ENV{rsat_www}|g;
  }

  ################################################################
  ## Create sub directories
  my $out_path = $main::output_dir."/".$main::output_prefix;
  &RSAT::util::CheckOutDir($out_path."IntermediateFiles");
  &RSAT::util::CheckOutDir($out_path."ResultsFiles");

  ## Set output files names
  #my $tmp_dir = &RSAT::util::get_pub_temp();

  $basename = $out_path."IntermediateFiles/".$main::output_prefix;
  $main::used_outfile{used_regulatory_regions} = $basename."network-interactions_used_regulatory_regions_".$date.".bed";
  $main::used_outfile{used_matrixes} = $basename."network-interactions_used_matrixes_".$date.".tf" unless ( $main::matrices );
  unless ( $main::seq ){
    $main::used_outfile{used_cre_seqs} = $basename."network-interactions_used_cre_seqs_".$date.".fa";
    $main::used_outfile{used_cre_seqs_geneheader} = $basename."network-interactions_used_cre_seqs_geneheader_".$date.".fa";
  }
  $main::used_outfile{used_matrix_scan_results} = $basename."network-interactions_used_matrix-scan_results_".$date.".tsv"  unless( $main::scan );

  $basename = $out_path."ResultsFiles/".$main::output_prefix;
  $main::outfile{log} = $basename."network-interactions_log_".$date.".txt";
  $main::outfile{complete_direct_interactions} = $basename."complete_direct_interactions_".$date.".tsv";
  if($report_net){
    $main::outfile{network_intersection} = $basename."network_intersection_".$date.".tsv";
    $main::outfile{network_rejected_interactions} = $basename."network_rejected_interactions_".$date.".tsv";
    $main::outfile{network_found_interactions} = $basename."network_found_interactions_".$date.".tsv";
  }
  $main::outfile{GRN_direct_interactions} = $basename."GRN_direct_interactions_".$date.".tsv";
  $main::outfile{GRN_indirect_interactions} = $basename."GRN_indirect_interactions_".$date.".tsv";

  #if ( $main::html == 1 );
  # html summary file
  $main::outfile{summary} = $basename."SUMMARY_".$date.".html";
  ## Archive to facilitate transfer of all the results in a zip file
  $main::outfile{archive} = $basename."archive_".$date.".zip";

  &RSAT::message::Debug("Archive", $main::outfile{archive}) if ($main::verbose >= 3);


  ################################################################
  #if ( $html == 1 )
  ## Taken from matrix-clustering
  ## Define the base directories for the javascripts, which are
  ## required to display logo trees, animations and dynamic tables

  if ($include_js_lib) {
## Note: we will need to redefine it after having parsed the
## arguments, since it will be relative to output directory.
&RSAT::message::Debug("Copying javascript libraries to output directory") if ($main::verbose >= 3);
my $js_sync_cmd = "rsync -ruptl";
$js_sync_cmd .= " ".$ENV{RSAT}."/perl-scripts/lib/js";
$js_sync_cmd .= " ".$output_dir;
#&doit($js_sync_cmd, 0, 1, $verbose, 0, "", $main::out, $main::err);
&doit($js_sync_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
$js_base = $output_dir."/js";
&RSAT::message::Info("Javascript libraries copied to output directory", $js_base) if ($main::verbose >= 3);
  }  elsif (defined($ENV{RSA_OUTPUT_CONTEXT}) && ($ENV{RSA_OUTPUT_CONTEXT} eq "cgi")) {
$js_base = $ENV{rsat_www}."/lib/js";
  } else {
## NOTE from JvH to Jaime: This solution does not allow to see the
## result on another computer than the RSAT server on which
## matrix-clustering ran.
$js_base = $ENV{RSAT}."/perl-scripts/lib/js";
  }
  $d3_base= &RSAT::util::RelativePath($main::outfile{summary}, $js_base."/d3.v3.min.js");
  $d3_venn_base= &RSAT::util::RelativePath($main::outfile{summary}, $js_base."/venn.js-master/venn.js");
  $jquery_base = &RSAT::util::RelativePath($main::outfile{summary}, $js_base."/DataTables-1.10.4/media/js/jquery.js");
  $datatable_base = &RSAT::util::RelativePath($main::outfile{summary}, $js_base."/DataTables-1.10.4/media/js/jquery.dataTables.min.js");
  $datatable_css_base = &RSAT::util::RelativePath($main::outfile{summary}, $js_base."/DataTables-1.10.4/media/css/jquery.dataTables.min.css");

  ################################################################
  ## Open logfile

  $log = &OpenOutputFile($main::outfile{log});
  &Verbose($log) if ($main::verbose >= 1);

  ################################################################

  ## Initialize archive file
  #my $archivefh;
  #$archivefh = &OpenOutputFile($main::outfile{archive});
  #&messageInfoAndLog("Initializing archive file ".$main::outfile{archive}."\n");
  #print $archivefh "Archive file\n";

  my ($archive_dir, $archive) = &SplitFileName($main::outfile{archive}); # $main::output_dir."/".$main::output_prefix."archive.zip"
  my ($archive_dir_dir, $archive_dir_base) = &SplitFileName($archive_dir);
#  $to_archive_rel_path = &RSAT::util::RelativePath($main::outfile{archive}, $to_archive);
  my $to_archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $to_archive);
  my $archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $main::outfile{archive});

  print("\n");
  print(" main::outfile{archive} ".$main::outfile{archive}."\n");
  print("\n");
  print(" archive_dir = ".$archive_dir."\n");
  print(" archive = ".$archive."\n");
  print(" archive_dir_dir = ".$archive_dir_dir."\n");
  print(" to_archive_rel_path = ".$to_archive_rel_path."\n");
  print(" archive_rel_path = ".$archive_rel_path."\n");
  print("\n");


  ################################################################

  # Decide which transfac files to use
  # CODE: add all from organism option

  if($main::databases eq ""){ # default option
    #print("Entered default option of dbs\n");
    $matfiles_path[0] = $ENV{RSAT}."/public_html/motif_databases/JASPAR/Jaspar_2020/nonredundant/JASPAR2020_CORE_vertebrates_non-redundant_pfms.tf";
    #$matfiles_path[0] = $ENV{RSAT}."/public_html/motif_databases/JASPAR/Jaspar_2018/nonredundant/JASPAR2018_CORE_vertebrates_non-redundant_pfms_transfac.tf";
    #print($matfiles_path[0]."\n");
  } else {
    if($main::databases eq "all"){ # CODE: falta anadir algo que soporte que meta los nombres de dbs como sea
      @dbs = qw(ENCODE epigram Hocomoco_human Hocomoco_mouse Homer hPDI HT_Selex Jolma_2013 Jolma_2015 NCAP-SELEX CAP-SELEX RSAT jaspar_core_redundant_all cisBP Yeastract DrosophilaTFs);
    } else { @dbs = split(/,|;/, $main::databases) }

    # retrieve paths to databases from db_matrix_files.tab
    open(my $dbs_file, "<", $ENV{RSAT}."/public_html/motif_databases/db_matrix_files.tab") or die "Cannot open file $!";
    $i = 0;
    while(my $row = <$dbs_file>){
      chomp($row);
      next if( $row =~ /^;/);
      next if( $row =~ /^#/);

      foreach my $db (@dbs){
        if( $row =~ /^$db/){
          @fields = split(/\t/,$row);
          $matfiles_path[$i++] = $ENV{RSAT}."/public_html/motif_databases/".$fields[2];
          #print(" matrix file path number ".$c." : ".$matfiles_path[$c]."\n");
          #$c++;
        }
      }
    }
    close $dbs_file;
  }
  &messageInfoAndLog("Number of motif databases = ".scalar(@matfiles_path)."\n");


  ################################################################
  ####################################### Save Input Data

  # Rewrite to bedfile without NAs or if no gene is refered to
  # Also, save the genes refered to in bed file of enhancers
  #        I want to preserve the order
  $val = 0; # first value is always 1 in hash
  $i = 1;

  my ($enhancer, $enh_dir) = &OpenInputFile($main::infile{cres});
  &messageInfoAndLog("# Reading BED file: ".$main::infile{cres}."\n");

  $new_enhancer = &OpenOutputFile($main::used_outfile{used_regulatory_regions});
  print $new_enhancer "# Bed file used for cis-regulatory regions\n";

  while(my $enh_row = <$enhancer>){
    chomp($enh_row);
    next unless ($enh_row =~ /\S/); ## Skip empty rows
    next if ($enh_row =~ /^;/); ## Skip comment rows
    next if ($enh_row =~ /^#/); ## Skip header rows

    if($enh_row =~ /^chr\w{1,2}\t\d+\t\d+\t(\w+).*/){
      if($1 ne "NA"){

          # write to new bed file and save order of genes
          print $new_enhancer $enh_row."\n";
          push(@genes_reg,$1);

          # add values in sequential order
          # gene is key, value is a number
          if( !$val ){
            $nonRep_genes_reg{$1} = $val++;
          } elsif(!$nonRep_genes_reg{$1}) {
            $nonRep_genes_reg{$1} = $val++;
          }

      }
    } else {
      print $log "\tGene name on fourth column missing at line: ".$i."\n"
      #&RSAT::error::FatalError("Error: not a fourth column of genes in file ".$main::cres."\n");
      #exit(1);
    }
    $i++;
  }

  close $enhancer;
  close $new_enhancer;

  &RSAT::error::FatalError("Error: not a single gene name was specified on bed file: ".$main::infile{cres}."\n") unless (scalar(@genes_reg) > 0);
  #print ("# of genes regulated = ".scalar(@genes_reg)."\n");
  #print ("# of nonRep genes regulated = ".scalar(keys %nonRep_genes_reg)."\n");

  #############################################################
  # Save non-repited TFs
  $i = 0;
  my $a = 0, $b = 0;

  my ($TF, $TF_dir) = &OpenInputFile($main::infile{TFs});
  &messageInfoAndLog("# Reading TFs list file: ".$main::infile{TFs}."\n");

  while( my $row = <$TF> ){
    next unless ($row =~ /\S/); ## Skip empty rows
    next if ($row =~ /^;/); ## Skip comment rows
    next if ($row =~ /^#/); ## Skip header rows
    chomp($row);

    # distinguish if their sequences were reported
    if ( $nonRep_genes_reg{$row} ){
      #print("Tf in nonRep_genes_reg\n");
      # add values in sequential order, beginning in 1
      if( !$i ){
        $nonRepTFs{$row} = $i++;
      } elsif(!$nonRepTFs{$row}) {
        $nonRepTFs{$row} = $i++;
      }

      # list of TFs with no coordinates
      if(!$b){
        $report_tfs_RegSeq = $row;
        $b++;
      } else {
        $report_tfs_RegSeq .= ",".$row;
      }

    } else {
      # list of TFs with no coordinates
      if(!$a){
        $report_tfs_noRegSeq = $row;
        $a++;
      } else {
        $report_tfs_noRegSeq .= ",".$row;
      }
    }

  }
  #print("# of nonRepTFs = ".%nonRepTFs."\n");
  close $TF;

  # notice user about the lack of regulatory seqences
  &messageInfoAndLog("Seems like you didn't reported the regulatory sequences for the following TFs : ".$report_tfs_noRegSeq."\n");
  if( $report_net){
      &messageInfoAndLog("The program will take into account the rest for further network comparision : ".$report_tfs_RegSeq."\n");
  }

  ## Check input TFs
  @nonRepTFs_k = keys %nonRepTFs;
  &RSAT::error::FatalError("Error: not a single TF was specified on: ".$main::infile{TFs}."\n") unless (scalar(@nonRepTFs_k) > 0);

  #############################################################
  # Save input network and create input GRN
  $flag = 0;
  $ngenes = scalar(keys %nonRep_genes_reg)-1;
  $ntfs = scalar(@nonRepTFs_k) -1;

  if($report_net){

    #initialize matrixes to zeros
    # input all-genes net
    #print($val."\n");
    for $i (0..$ngenes){
        for my $j (0..$ngenes){
  	  $net_old_allgenes[$i][$j] = 0;
        }
    }
    # input only-TFs net
    for $i (0..$ntfs){
        for my $j (0..$ntfs){
  	  $net_old_onlyTFs[$i][$j] = 0;
        }
    }

    $i = 0;
    # Save input network interactions
    my ($net, $net_dir) = &OpenInputFile($main::infile{network});
    &messageInfoAndLog("Reading input network file: ".$main::infile{network}."\n");

    while (my $net_row = <$net>){
        chomp($net_row);
        next unless ($net_row =~ /\S/); ## Skip empty rows
        next if ($net_row =~ /^;/); ## Skip comment rows
        next if ($net_row =~ /^#/); ## Skip header rows

        @fields = split(/\t|,/, $net_row);

        # make list of genes in network with regulatory sequences reported and not reported
        if($nonRep_genes_reg{$fields[0]}){
          $RegSeq{$fields[0]} = $z++;
      	  $flag++;
        } else {
      	  $noRegSeq{$fields[0]} = $z++;
        }
        if($nonRep_genes_reg{$fields[1]}){
      	  $RegSeq{$fields[1]} = $z++;
      	  $flag++;
        } else {
      	  $noRegSeq{$fields[1]} = $z++;
        }

        # Note: In the network comparison report, only interactions in which both genes had their seq reported will be taken into account

        # if both genes have a reported regulatory sequence
        if( $flag == 2 ){
          # construct network of all genes
          $net_old_allgenes[ $nonRep_genes_reg{$fields[0]}-1 ][ $nonRep_genes_reg{$fields[1]}-1 ] = 1;
          # if the interaction is between TFs, add this one to the input's only-TFs network
          if( $nonRepTFs{$fields[0]} && $nonRepTFs{$fields[1]} ){
            $net_old_onlyTFs[ $nonRepTFs{$fields[0]}-1 ][ $nonRepTFs{$fields[1]}-1 ] = 1;
          }
        }
        # reinitialize value
        $flag =0;

      } # while
      close $net;

      # message if sequences of any genes in network were not reported
      if(%noRegSeq){
        $a = 0;
        foreach my $gene (sort keys %noRegSeq){
          if(!$a){
            $noRegSeq_reporting = $gene;
            $a++;
          } else {
            $noRegSeq_reporting .= ",".$gene;
          }
        }
        $a = 0;
        foreach my $gene (sort keys %RegSeq){
          if(!$a){
            $RegSeq_reporting = $gene;
            $a++;
          } else {
            $RegSeq_reporting .= ",".$gene;
          }
        }

        # Tell user which regulatory sequences are lacking and which genes are used in the program
        &messageInfoAndLog("Seems like you didn't reported the regulatory sequences for the following genes in your input network: ".$noRegSeq_reporting."\n");
        &messageInfoAndLog("The program will use the rest of the genes for further network comparison: ".$RegSeq_reporting."\n");
      } # Info
  } # report_net

  ################################################################
  ####################################### RSAT processing
  &messageInfoAndLog("Initiating RSAT tools processing ...\n");

  unless( $main::scan ){ ## unless scan results are provided

    # Create the file with all the matrixes to use
    #   retrieve-matrix foreach database foreach TF
    unless ( $main::matrices ){
      &messageInfoAndLog("Retrieving matrixes ...\n");
      foreach my $db (@matfiles_path){
        $ACs = &retrieveACsfromTFs($db, @nonRepTFs_k);
        my $retrieve_matrix_cmd = &RSAT::server::GetProgramPath("retrieve-matrix");
        $cmd = "$retrieve_matrix_cmd -i ".$db." -id ".$ACs." >> ".$main::used_outfile{used_matrixes};
        &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
        #system ($cmd);
        #die "BOOM";
      }
      &messageInfoAndLog("\tGot matrixes!\n");
    }

    # Retrieve sequences of regulatory elements
    unless( $main::seq ){
      &messageInfoAndLog("Retrieving enhancer sequences ...\n");
      $cmd = &RSAT::server::GetProgramPath("fetch-sequences") . " -i ".$main::used_outfile{used_regulatory_regions}." -genome ".$main::genome." -v 1 -header_format galaxy -o ".$main::used_outfile{used_cre_seqs}."";
      &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
      &messageInfoAndLog("\tDone!\n");

      # Add regulated genes names to fasta of regulatory sequences
      #     Im using 'external_id' not ensembl_id
      open( $fasta, "<", $main::used_outfile{used_cre_seqs} ) or die "Cannot open file $!";
      open( $new_fasta, ">", $main::used_outfile{used_cre_seqs_geneheader} ) or die "Cannot open file $!";

      $i = 0;
      while(my $fa_row = <$fasta> ){
        chomp($fa_row);
        if($fa_row =~ /^>/){
          print $new_fasta $fa_row."_*_".$genes_reg[$i++]."\n";# this must be at the identifier line e.g.: >seq1_*_$genes_reg[$i++]
                                                               #  only so that matrix-scan takes this whole name as seq_id
        } else {
          print $new_fasta $fa_row."\n";
        }
      }
      close $fasta;
      close $new_fasta;
    }

    # Search motifs in all regulatory sequences
    &messageInfoAndLog("matrix-scan running ...\n");
    $cmd = &RSAT::server::GetProgramPath( "matrix-scan")." -quick -v 1 -matrix_format transfac -m ".$main::used_outfile{used_matrixes}." -bginput -markov 1";
    $cmd.= " -i ".$main::used_outfile{used_cre_seqs_geneheader}." -o ".$main::used_outfile{used_matrix_scan_results}."";
    $cmd.= " -id_as_name -lth score ".$main::score;
    $cmd.= " -uth pval ".$main::pval if ( $main::pval ne 'NA' );
    &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
    &messageInfoAndLog("\tDone!\n");

  } # unless scan

  &messageInfoAndLog("RSAT tools processing ready.\n");

  ################################################################
  ## Constuct networks and save matrix-scan details of interactions

  for $i (0..$ngenes){
    for my $j (0..$ngenes){
      $net_new_allgenes[$i][$j] = 0;
    }
  }
  # input only-TFs net
  for $i (0..$ntfs){
    for my $j (0..$ntfs){
      $net_new_onlyTFs[$i][$j] = 0;
    }
    # initialize to zeros
    $deadend[$i] = 0;
  }

  &messageInfoAndLog("Network computation running ...\n");
  # Create matrixes of networks:
  open($matrixscan_re, "<", $main::used_outfile{used_matrix_scan_results} ) or die "Cannot open file $!";

  $a = 1;
  while(my $results_row = <$matrixscan_re>){
    chomp($results_row);
    next unless ($results_row =~ /\S/); ## Skip empty rows
    next if ($results_row =~ /^;/); ## Skip comment rows
    next if ($results_row =~ /^#/); ## Skip header rows

    @fields = split(/\t/,$results_row); # $fields[2] is the TF
    @seq_id = split(/_/,$fields[0]); # >genome_chr_start_end_+_genename
    @gene_name = split(/_\*_/,$fields[0]);

    if($nonRep_genes_reg{$gene_name[1]} && $nonRep_genes_reg{$fields[2]}){ # no error
      if( !$net_new_allgenes[ $nonRep_genes_reg{$fields[2]}-1 ][ $nonRep_genes_reg{$gene_name[1]}-1 ] ){

          # set interaction in directed-network
          $net_new_allgenes[ $nonRep_genes_reg{$fields[2]}-1 ][ $nonRep_genes_reg{$gene_name[1]}-1] = 1;

          # if it is a TF-TF interaction, save it on the GRN
          if ($nonRepTFs{$fields[2]} && $nonRepTFs{$gene_name[1]}){
            $net_new_onlyTFs[ $nonRepTFs{$fields[2]}-1 ][ $nonRepTFs{$gene_name[1]}-1 ] = 1;
          }
      }
      $interaction_details{$fields[2]}{$gene_name[1]}{$seq_id[1].":".$seq_id[2]."-".$seq_id[3]}{$fields[3]."_".$fields[4]."_".$fields[5]}{$fields[7]} = $a++;

    }

  } #  while
  close $matrixscan_re;

  ########################################################################
  ################### Comparisons and write-to-file reporting
  my %nonRep_genes_reg_inv;
  my $rowtofile;
  $tables_str{complete_direct_interactions} = "";

  &messageInfoAndLog("Also creating output files ...\n");
  ## Comparison of complete gene network
  $interaction_gene_row = &OpenOutputFile($main::outfile{complete_direct_interactions});
  &Verbose($interaction_gene_row) if ($main::verbose >= 1);
  print $interaction_gene_row "# Complete Network\n#TF\tGene\tCoordinates\tPositions\tScores\n"; # header

  if( $report_net ){
    $intersection = &OpenOutputFile($main::outfile{network_intersection});
    &Verbose($intersection) if ($main::verbose >= 1);
    print $intersection "# Interactions in common from:\n#\t".$main::infile{network}." and ".$main::outfile{complete_direct_interactions}."\n#TFx\tGeney\tCoordinates\tPositions\tScores\n"; # header
    $rejected = &OpenOutputFile($main::outfile{network_rejected_interactions});
    &Verbose($rejected) if ($main::verbose >= 1);
    print $rejected "# Interactions in:\t".$main::infile{network}." not found in ".$main::outfile{complete_direct_interactions}."\n#Genex\tGeney\tCoordinates\tPositions\tScores\n"; # header
    $found = &OpenOutputFile($main::outfile{network_found_interactions});
    &Verbose($found) if ($main::verbose >= 1);
    print $found "# Newly found interactions in:\t".$main::outfile{complete_direct_interactions}." not found in ".$main::infile{network}."\n#TFx\tGeney\tCoordinates\tPositions\tScores\n"; # header
  }

  %nonRep_genes_reg_inv = reverse %nonRep_genes_reg;

  for $i (0..$ngenes){
    for my $j (0..$ngenes){

        # write interaction to file according to the case: intersection, rejected or newly found
        if( $net_new_allgenes[$i][$j] ){

          $rowtofile = &writeRow( $nonRep_genes_reg_inv{ $i+1 }, $nonRep_genes_reg_inv{ $j+1 }, \%{ $interaction_details{$nonRep_genes_reg_inv{ $i+1 }}{$nonRep_genes_reg_inv{ $j+1 }} } );
          #push($tables_str{complete_direct_interactions}, $rowtofile);
          $tables_str{complete_direct_interactions} .= $rowtofile;

          print $interaction_gene_row $rowtofile;

          if( $report_net ){
            if( $net_old_allgenes[$i][$j] ){
              # overlap (only interactions, not lack of them)
              print $intersection $rowtofile;
            } else {
              # newly found
              print $found $rowtofile;
            }
          } # report_net

        } elsif( $report_net && $net_old_allgenes[$i][$j] ){
            # rejected (no details)
            print $rejected $nonRep_genes_reg_inv{ $i+1 }."\t".$nonRep_genes_reg_inv{ $j+1 }."\n";
        }


    } # for
  } # for

  ## Comparison of GRNs ?

  ################################################################
  ## Report all direct interactions within TFs

  open( $direct, ">", $main::outfile{GRN_direct_interactions} ) or die "Cannot open file $!";
  &Verbose($direct) if ($main::verbose >= 1);
  print $direct "#Regulator\tRegulated\tCoordinates\tPositions\tScore\n"; # header

  %nonRepTFs_inv = reverse %nonRepTFs;
  $count = 0;

  for my $i (0..$ntfs){
    for my $j (0..$ntfs){

      # write to file direct interactions
      if( $net_new_onlyTFs[$i][$j] ){

        $rowtofile = &writeRow( $nonRepTFs_inv{ $i+1 }, $nonRepTFs_inv{ $j+1 }, \%{ $interaction_details{$nonRepTFs_inv{ $i+1 }}{$nonRepTFs_inv{ $j+1 }} } );
        print $direct $rowtofile;

      } else {
        # add node to list of deadend nodes
        if($count == $ntfs){
          $deadend[$i] = 1;
        }
        $count++;
      }

    } # for
  } # for


  ################################################################
  ##  Report all indirect interactions, i.e., direct interactions
  ##    composed of three nodes
  # E.g.:
  #   IN GRN_direct_interactions.tsv:
  # TF1 TF2
  # TF2 TF3
  # TF1 TF3
  #   IN GRN_indirect_interactions.tsv_:
  # TF1 ==> TF2 ==> TF3
  # TF2 ==> TF3
  # TF1 ==> TF3
  # Interpretation: TF1 regulates directly and indirectly TF3.

  $path = "\n"; # string to concat paths of 3 nodes
  my $details1 = "";
  my $details2 = "";
  my $coo = "";

  ## Report all paths of three (instead of cases of direct and indirect interactions simoultaneously)
  open( my $indirect, ">", $main::outfile{GRN_indirect_interactions}) or die "Cannot open file $!";
  &Verbose($indirect) if ($main::verbose >= 1);
  print $indirect "# Report of 3-nodes direct interactions\n# cases of no direct interactions are specified.\n#node1 ==> node2 ==> node3\n\n"; #header

  for my $row (0..$ntfs){
    #$path = "";
    # check if the node is a deadend
    if ( !$deadend[$row] ){
      for my $con1 (0..$ntfs){
        # find direct connections
        if( $net_new_onlyTFs[$row][$con1] ){

          $details1 = &writeRow( $nonRepTFs_inv{ $row+1 }, $nonRepTFs_inv{ $con1+1 }, \%{ $interaction_details{$nonRepTFs_inv{ $row+1 }}{$nonRepTFs_inv{ $con1+1 }} } );

          # construct path
          $path .= $nonRepTFs_inv{ $row+1 }."\t==>\t".$nonRepTFs_inv{ $con1+1 };
          # report if its a connection to itself
          if ($row == $con1){
            print $indirect $path."\n";
            print $indirect $details1."\n";
          } elsif ( !$deadend[$con1] ){

            for my $con2 (0..$ntfs){
              # skip it its a connection to itself
              if( $con1 == $con2){ next; }
              if( $net_new_onlyTFs[$con1][$con2] ){

                $details2 = &writeRow( $nonRepTFs_inv{ $con1+1 }, $nonRepTFs_inv{ $con2+1 }, \%{ $interaction_details{$nonRepTFs_inv{ $con1+1 }}{$nonRepTFs_inv{ $con2+1 }} } );

                # report 3-node connection to file
                $path .= "\t==>\t".$nonRepTFs_inv{ $con2+1 };
                print $indirect $path."\n";
                print $indirect $details1."==>\n".$details2."\n";
                # set the 2-node connection for more 3-node connections
                $path = "\n".$nonRepTFs_inv{ $row+1 }."\t==>\t".$nonRepTFs_inv{ $con1+1 };
              } # direct connection 2 found
            }

          } else {
            # if it was a dead end report 2-node connection
            print $indirect "".$path."\n";
            print $indirect $details1."\n";
          }
          $path = "\n";

        } # direct connection 1 found
      } # for connection 1
    } else {
      print $indirect "".$nonRepTFs_inv{ $row+1 }." has no targets.\n";
      $path = "\n";
    }

  } # for row
  &messageInfoAndLog("\tDone.\n");

  ################################################################
  ## here is what was in sub &close_and_quit()
  ## Close output file and quit

  &messageInfoAndLog("Closing output files ... \n");
  ## Report execution time
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts

  if ($main::verbose >= 1) { ## only report exec time if verbosity is specified
      while (my ($key,$value) = each %main::outfile) {
          print $interaction_gene_row $exec_time;
          if( $report_net ){
            print $intersection $exec_time;
            print $found $exec_time;
            print $rejected $exec_time;
          }
          print $direct $exec_time;
          print $indirect $exec_time;
      }

      if ($main::verbose > 1){
        foreach my $key ( sort keys %main::outfile) {
          &RSAT::message::TimeWarn("Results files", $main::outfile{$key});
        }
      }
  }

  close $interaction_gene_row;
  if( $report_net ){
    close $intersection;
    close $found;
    close $rejected;
  }
  close $direct;
  close $indirect;
  &messageInfoAndLog("\tDone. \n");

  if ($main::html == 1) {
    &messageInfoAndLog("Creating HTML summary ... \n");

    ################################################################
    ## Check output directories and define file names
    #&set_output_file_names();

    ## Initialize HTML summary
    &OpenSynthesis(); #if ($main::param{progressive_synthesis}); ## Already open the HTML report summary, for the Web site
    #if ($root_matrices_flag == 1) {
    #    $to_delete{'summary'} = $main::outfile{summary};
    #}

    ################################################################
    ## Make output summary html file

    #&ConvertTabToHTML(@tab_to_convert);

    ################################################################
    ## Creates the website
    &Synthesis();

    ################################################################
    ## Create an archive with all result files
  #  &Archive(1);
  }

  &messageInfoAndLog("End of program.\n");

  print $log $exec_time;
  close $log;

  exit(0);

} # main




################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Display full help message
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments
sub ReadArguments {

    my $arg;

    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()

    while (scalar(@arguments) ) {
	$arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity.

=cut

	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message.

=cut

	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    ## Dry run

=pod

=item B<-help>

Same as -h.

=cut

	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## TFs input file

=pod

=item B<-tfs TFs_infile>

Mandaroty.
File containing a list of TFs to be analysed
One-column input file with list of TFs in network.

=cut

	}elsif ($arg eq "-tfs") {
	    $main::infile{TFs} = shift(@arguments);

	    ## Regulatory sequences file

=pod

=item B<-cre cre_infile>

Mandaroty.
Bed file with of regulatory sequences per gene in network.
Each sequence must refer to its regulated-gene on the 4th column.

=cut

	} elsif ($arg eq "-cre") {
	    $main::infile{cres} = shift(@arguments);

	    ## Genome version

=pod

=item B<-genome genome_version>

Mandaroty.
Working genome version.

=cut

	} elsif ($arg eq "-genome") {
	    $main::genome = shift(@arguments);

=pod

=item B<-db databases>

Database(s) to use separated by commas.

=cut
	} elsif ($arg eq "-db") {
	    $main::databases = shift(@arguments);

	    ## Network file

=pod


=item B<-net network_infile>

Mandaroty if -report_net is specified.
The network must be a two-column file with each row containing a single interaction.

=cut
	} elsif ($arg eq "-net") {
	    $main::infile{network} = shift(@arguments);
	    $main::report_net = 1;

	    ## Report Network
=pod

=item B<-report_net>

Report network,
i.e., differences and overlap between the input network and the new network are outputted

=cut

	} elsif ($arg eq "-report_net") {
	    $main::report_net = 1;

	    ## Title

=pod

=item B<-title title>

Title displayed on top of the report page.

=cut
	} elsif ($arg eq "-title") {
	    $main::title = shift(@arguments);

      ## HTML summary page

=pod

=item B<-html>

Output html SUMMARY file

=cut
      } elsif ($arg eq "-html") {
      $main::html = 1;

      ## Date

=pod

=item B<-date date>

Date used as suffix for output files.

=cut
     } elsif ($arg eq "-date") {
      $main::date = shift(@arguments);

      ## Input sequences
=pod

=item B<-seq input_sequences>

Fasta file with of regulatory sequences per gene in network.
Each sequence must refer to its regulated-gene on its header by tag.
Regulatory sequences of TFs in the network should be incorporated.

=cut
	} elsif ($arg eq "-seq") {
	    $main::used_outfile{used_cre_seqs_geneheader} = shift(@arguments);
      $main::seq = 1;

	    ## Input matrices
=pod

=item B<-m matrices-file>

File of matrices in transfac fomat including the TF name on the
ID field.

=cut
	} elsif ($arg eq "-m") {
	    $main::used_outfile{used_matrixes} = shift(@arguments);
      $main::matrices = 1;

	    ## matrix-scan result
=pod

=item B<-scan matrix-scan-results-file>

File resulting from matrix-scan on regulatory sequences
for the TFs' matrices of interest.

=cut
	} elsif ($arg eq "-scan") {
	    $main::used_outfile{used_matrix_scan_results} = shift(@arguments);
      $main::scan = 1;

      ## Score
=pod

=item B<-score #>

Score lower threshold to run matrix-scan with, default is 5.

=cut
	} elsif ($arg eq "-score") {
	    $main::score = shift(@arguments);
      unless ( &IsNatural($main::score) ){
        &RSAT::error::FatalError("Score should be a natural number or 0.");
      }

      ## Pval
=pod

=item B<-pval #>

P-value upper threshold to run matrix-scan with.

=cut
	} elsif ($arg eq "-pval") {
	    $main::pval = shift(@arguments);

	    ## Archive_format
=pod

=item B<-archive_format [zip|tar|tgz]>

Archive format: zip (default), tar or tgz

=cut
	} elsif ($arg eq "-ar_format") {
	    $main::archive_format = shift(@arguments);
      unless ($main::archive_format eq "zip" || $main::archive_format eq "tar" || $main::archive_format eq "tgz"){
        &RSAT::error::FatalError("Invalid archive format. Must be zip, tar or tgz.");
      }

      ## Output prefix
=pod

=item B<-o output_prefix>

Prefix for the output files.

=cut
  } elsif ($arg eq "-o") {
      $main::output_prefix = &trim(shift(@arguments))."_";
      #$main::outfile{prefix} = shift(@arguments);


	    ##Output dir

=pod

=item B<-outdir output_dir>

Output dir

=cut

	} elsif ($arg eq "-outdir") {
	    $main::output_dir = &trim(shift(@arguments));
	    # $main::dir{output}
	}
	else {
	    &FatalError(join("\t", "Invalid option", $arg));
	}
    } # while

=pod

=back

=cut

} # sub ReadArguments


################################################################
## Verbose message
sub Verbose {
    my($out) = @_;

    print $out "; network-interactions ";
    &PrintArguments($out);
    #printf $out "; %-22s\t%s\n", "Program version", $program_version;
    if (%main::infile) {
        print $out "; Input files\n";
        while (my ($key,$value) = each %main::infile) {
            printf $out ";\t%-13s\t%s\n", $key, $value;
        }
    }
    if (%main::outfile) {
        print $out "; Results files\n";
        while (my ($key,$value) = each %main::outfile) {
            printf $out ";\t%-13s\t%s\n", $key, $value;
        }
    }
    if (%main::used_outfile) {
        print $out "; Intermediate files\n";
        while (my ($key,$value) = each %main::used_outfile) {
            printf $out ";\t%-13s\t%s\n", $key, $value;
        }
    }
}


################################################################
## Obtain list of the accesions from specified TFs to call retrieve-matrix on
sub retrieveACsfromTFs {
    my ($database, @TFnames) = @_;

    # Check in which field the TF name appears
    my $nameinAC = 0; # boolean to check if TFname is in AC field or ID
    my @cols; # list of elementes in field AC
    my $retrievingACs = ""; # final "list" with all AC's from the TFnames required

    open( my $db, "<", $database) or die "Cannot open file $!";
    while(my $db_row = <$db>){
        chomp($db_row);
        next unless($db_row =~ /^AC/ || $db_row =~ /^ID/);
        if( $db_row =~ /^AC\s+[^MA{0,1}\d{4,5}(_\d){0,1}(\.\d+){0,1}]/){ # si encuentra algo distinto de MA..
            $nameinAC = 1;
            last;
        } elsif( $db_row =~ /^ID\s+[^MA{0,1}\d{4,5}(_\d){0,1}(\.\d+){0,1}]/){
            $nameinAC = 0;
            last;
        } # else, no TFname provided
    } #while
    close $db;

    # Generate array of ACs
    open( $db, "<", $database) or die "Cannot open file $!";

    while(my $db_row = <$db>){ # does this continues from the line before or does it starts over again
        chomp($db_row);
        next unless($db_row =~ /^AC/ || $db_row =~ /^ID/);

        if( $db_row =~ /^AC/){
            @cols = split(/\s+/,$db_row); # save AC for each TF
            #print(" AC = ".$cols[1]."\t");
        }
    #    if( $nameinAC ){
    #      next unless($db_row =~ /^AC/);
    #    } else {
    #      next unless($db_row =~ /^ID/);
    #    }
#
#        foreach my $name (@TFnames){
#          if( $db_row =~ /.*$name.*/){
#            $retrievingACs .= $cols[1].",";
#          }
#        }
        foreach my $name (@TFnames){
            if( $db_row =~ /.*$name.*/){
              if( !$nameinAC && $db_row =~ /^ID/){ # if TF name is found in ID field
                $retrievingACs .= $cols[1].",";
              } elsif( $nameinAC && $db_row =~ /^AC/){ # if TF name is found in AC field
                $retrievingACs .= $cols[1].",";
              }
            } # if
        } # foreach
    } # while
    close $db;

    return $retrievingACs;
} # sub

## Compose row of interaction with details to write to files
sub writeRow {
  my ( $TF, $target, $interaction_details ) = @_;
  my ($rowtofile, $pos, $scores, $i);
  $rowtofile = "";

  foreach my $coordinates ( keys %{ $interaction_details }){
    # report direct interaction TFx Geney
    $rowtofile .= $TF."\t".$target."\t".$coordinates;  #    TFx (regulates) Genex (in) Coordinates

    $pos = "";
    $scores = "";
    foreach my $positions ( keys %{ $interaction_details->{$coordinates} } ){
      if ($pos eq ""){
        $pos = $positions."";
        $i=0;
        # annotate each score assignated to the same positions
        foreach my $s ( keys %{ $interaction_details->{$coordinates}->{$positions} } ) {
          if(!$i){
            $scores = $s."";
            $i++;
          } else {
            $scores .= "_".$s;
          }
        } # foreach score
      } else {
        $pos .= ";".$positions;
        $i=0;
        # annotate each score assignated to the same positions
        foreach my $s ( keys %{ $interaction_details->{$coordinates}->{$positions} } ) {
          if(!$i){
            $scores .= ";".$s;
            $i++;
          } else {
            $scores .= "_".$s;
          }
        } # foreach score
      }
    } # foreach position
    $rowtofile .= "\t".$pos."\t".$scores."\n"; # (in) Positions (with) Scores
  }

  return $rowtofile;
}

## Output INFO message to STDOUT and to log file
sub messageInfoAndLog {
  my ($message) = @_;

  print $log "\n".$message;
  &RSAT::message::Info($message) if ($main::verbose >= 0 );

}

################################################################################
####                                                                        ####
####           Functions to make html SUMMARY output file                   ####
####                        adapted from matrix-clustering                  ####
####                                                                        ####
################################################################################

################################################################
## Index a table to convert to HTML
#sub AddTabToConvert { ## used in set_output_file_names
#                      ## crea la version en html de varios archivos de salida
#  my ($key) = @_;
#  my $tab = $main::outfile{$key};
#  my $html_key = $key."_html";
#  my $html = $tab."_html";
#  $html =~ s/\.tab.html$/\.html/;
#  $html =~ s/\.txt.html$/\.html/;
#  $main::outfile{$html_key} = $html; push @outfiles, $html_key;
#  push @tab_to_convert, $key; ## Add the key to the list to be converted
#}

################################################################
## Convert tab-delimited files in HTML
#sub ConvertTabToHTML {
#  my @tab_to_convert = @_;
#  &RSAT::message::TimeWarn("Converting tab-delimited to HTML files") if ($main::verbose >= 2);
#  for my $key (@tab_to_convert) {
#    my $tab = $main::outfile{$key};
#    my $html_key = $key."_html";
#    my $html = $main::outfile{$html_key};
#    my $cmd = &RSAT::server::GetProgramPath("text-to-html");
#    $cmd .= " -i ".$tab;
#    $cmd .= " -o ".$html;
#    &doit($cmd, 0, $die_on_error, $verbose, 0, "", $main::outfile{log});
#    #&doit($cmd, 0, $die_on_error, $verbose, 0, "", $main::outfile{log}, $main::err);
#  }
#}


###############################
## Export the cluster header
sub Text_end_report {

    my $end_report = '
 <!--       <div id="References_Button" class="button_click Section_button selected_header_section" style="margin-top:2px;"><strong>References</strong></div> -->
	<div id="end_report" style="margin-bottom:20px;">
	  <ul style="list-style: none;">
	    <li>
	      <strong>References</strong>
              <ol>
                 <li><strong>Last RSAT release: </strong><a href="https://academic.oup.com/nar/article/46/W1/W209/4990780" target=\'_blank\'>Nguyen NTT et al. RSAT 2018: regulatory sequence analysis tools 20th anniversary. Nucleic Acids Research (2018).</a></li>
              </ol>
	    </li>
	    <li>
	      <strong>Additional Information</strong>
              <ul>
                 <li type="square"><a href="http://pedagogix-tagc.univ-mrs.fr/courses/SBBCU16L_cisreg/" target=\'_blank\'>Jacques van Helden course</a></li>
              </ul>
	    </li>
	    <li>
	      <strong>Contact</strong>
              <ul>
                 <li type="square"><a href="http://folk.uio.no/jamondra/" target=\'_blank\'>Jaime Castro-Mondragon</a> - <strong>j.a.c.mondragon@ncmm.uio.no</strong></li>
                 <li type="square"><a href="http://morgane.bardiaux.fr/" target=\'_blank\'>Morgane Thomas-Chollier</a> - <strong>mthomas@biologie.ens.fr</strong></li>
                 <li type="square"><a href="http://jacques.van-helden.perso.luminy.univ-amu.fr/" target=\'_blank\'>Jacques van Helden</a> - <strong>Jacques.van-Helden@univ-amu.fr</strong></li>
              </ul>
            </li>
          </ul>
	</div>';

    print $syn $end_report."\n";
}


################################################################
## Generate a compressed archive with all the results
sub Archive {

  my ($remove_first, $to_archive) = @_;
  &RSAT::message::TimeWarn("\n; Archiving data and results") if ($main::verbose >= 2);

  ## Delete previous version of the archive to avoid including the old archive in the new one
  $cmd .= "rm -f ".$main::outfile{archive}."; " if ($remove_first); # used only once

  ################################################################
  ## Define archiving parameters

  ## By default, archive the whole output directory
  $to_archive = $main::output_dir unless $to_archive;

  ## Archive all data and results
  my ($archive_dir, $archive) = &SplitFileName($main::outfile{archive}); # $main::output_dir."/".$main::output_prefix."archive.zip"
  my ($archive_dir_dir, $archive_dir_base) = &SplitFileName($archive_dir);
#  $to_archive_rel_path = &RSAT::util::RelativePath($main::outfile{archive}, $to_archive);
  my $to_archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $to_archive);
  my $archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $main::outfile{archive});

  print("\n");
  print(" main::outfile{archive} ".$main::outfile{archive}."\n");
  print("\n");
  print(" archive_dir = ".$archive_dir."\n");
  print(" archive = ".$archive."\n");
  print(" archive_dir_dir = ".$archive_dir_dir."\n");
  print(" to_archive_rel_path = ".$to_archive_rel_path."\n");
  print(" archive_rel_path = ".$archive_rel_path."\n");
  print("\n");

  ## TO CHECK (Jacques)
  if ($main::verbose >= 3) {
    &RSAT::message::Debug("folder to archive", $to_archive);
  }

  ## Avoid crash of the program when run from the "$archive_dir_dir"
  if ($archive_dir_dir eq "") {
    $archive_dir_dir = ".";
    $to_archive_rel_path = $to_archive;
    $archive_rel_path = $main::outfile{archive};
  }

  my $cmd = "";
  if ($main::archive_format eq "zip") {
    $cmd .= "(cd ".$archive_dir_dir." ; ";
    $cmd .= " zip -ry ".$archive_rel_path." ".$to_archive_rel_path;
    $cmd .= " -x ".$archive;
    $cmd .= ")";
  } elsif (($main::archive_format eq "tar") ||
	   ($main::archive_format eq "tgz")) {
    $cmd .= "tar -cpf ".$main::outfile{archive};
    $cmd .= " -z" if ($main::archive_format eq "tgz");
    $cmd .= " -C ".$archive_dir_dir; ## Avoid including the whole path in the archive paths
    $cmd .= " --exclude ".$archive;
    $cmd .= " ".$to_archive_rel_path;
  } else {
    &RSAT::error::FatalError($main::archive_format, "Invalid archive format. Supported: zip, tar, tgz.");
  }

  print $cmd."\n";

  &one_command($cmd, 1);

  &RSAT::message::TimeWarn("Archive", $main::outfile{archive}) if ($main::verbose >= 2);
}

##########################################
## Open the HTML page for the synthesis
sub OpenSynthesis {

  my $refresh_time;
  #if ($main::param{progressive_synthesis}) {
    $refresh_time = 90;
  #} else {
  #   $refresh_time = 0;
  #}

  ## Open the summary HTML file
  $syn = &OpenOutputFile($main::outfile{summary});
  #$synthesis_path = `dirname $main::outfile{summary}`; # doesnt work
  my ($synthesis_path, $syn_name) = &RSAT::util::SplitFileName($main::outfile{summary});
  chomp($synthesis_path);

  my $html_lib = ""; # code library for style
  # /* to delete? */
  #if ($root_matrices_flag == 0) {
      ## Add the JS libraries paths
      $html_lib .= '
   <script type="text/javascript" src="'.$d3_base.'"></script>
   <script type="text/javascript" src="'.$jquery_base.'"></script>
   <script type="text/javascript" src="'.$datatable_base.'"></script>
   <link rel="stylesheet" type="text/css" href="'.$datatable_css_base.'">
</head>
     ';
  #}
  # /* ? */

  ## Add the CSS style for matrix-clustering summary and
  ## concatenate it to header the CSS sytles
  my $css_matrix_clustering = &ReportStyleCSS();
  $html_lib .= $css_matrix_clustering."\n";

  my $head = &PrintHtmlResultHeader(program=>"network-interactions", "title"=>$main::param{title}, "result_toc"=>1, refresh_time=>$refresh_time);
  $head =~ s|</head>|$html_lib|;

  print $syn $head;

  &ReportCommand();
}


sub ReOpenSynthesis {

  unlink($main::outfile{summary});
  close($syn);

  ## Open the summary HTML file
  $syn = &OpenOutputFile($main::outfile{summary});
  $synthesis_path = `dirname $main::outfile{summary}`;
  chomp($synthesis_path);

  my $html_lib = ""; # code library for style
  # /* to delete? */
  #if ($root_matrices_flag == 0) {
      ## Add the JS libraries paths
      $html_lib .= '
   <script type="text/javascript" src="'.$d3_base.'"></script>
   <script type="text/javascript" src="'.$jquery_base.'"></script>
   <script type="text/javascript" src="'.$datatable_base.'"></script>
   <link rel="stylesheet" type="text/css" href="'.$datatable_css_base.'">
</head>
     ';
  #}
  # /* ? */

  ## Add the CSS style for matrix-clustering summary and
  ## concatenate it to header the CSS sytles
  my $css_matrix_clustering = &ReportStyleCSS();
  $html_lib .= $css_matrix_clustering."\n";

  my $head = &PrintHtmlResultHeader(program=>"network-interactions", "title"=>$main::param{title});
  $head =~ s|</head>|$html_lib|;

  print $syn $head;

  &ReportCommand();
}


##########################################
sub CloseSynthesis {
    print $syn "</body>\n";
    print $syn "</html>\n";
    close $syn;
}

################################################################
## /* to delete? */
## Report the command before running the analysis, for the sake of
## debugging and to facilitate copy-paste of the options.
#sub ReportCommandLoading {
#  print $syn "<div width='1250px'; height='auto'; ><img style='padding-left:700px;height:500px;width:500px'; src='".$icons{loading}."'></div>";
#  print $syn &open_menu_heading($menu_nb++, "<a name='logs'></a><h3>Command</h3>", 1);
#  print $syn "<pre>";
#  print $syn "matrix-clustering ";
#  &PrintArguments($syn);
#  print $syn "</pre>";
#  print $syn &close_menu_heading();
#}
## /* ? */

sub ReportCommand {

  print $syn &open_menu_heading($menu_nb++, "<a name='logs'></a><h3>Command</h3>", 1);
  print $syn "<pre>";
  print $syn "network-interactions ";
  &PrintArguments($syn);
  print $syn "</pre>";
  print $syn &close_menu_heading();
}


#################################################
## CSS style for the matrix-clustering summary
## (dynamic tables + D3 trees)
sub ReportStyleCSS{
    my $CSS_mat_clus = '
<style>

  h3 a:hover {
	font-weight: bold;
	text-decoration: none;
  }


  .cluster_division {
	background-color: '.$blue_color.';
	float: left;
	margin: 5px 3px 3px 3px;
	width: auto;
	height: 15px;
	position: relative;
	display: inline-block;
	text-align: center;
	color: '.$font_color.';
	font-size: 12px;
	padding: 4px;
	cursor: pointer;
	border-radius:5px;
	border: 1px solid #819FF7;
  }


  .button_click:active {
  position:relative;
  top:1px;
  }

  .tab{
    font-size: 10px;
    margin-top: 3px;
    text-align: center;
    text-decoration: none;
    display: block;
    background-color: #E6E6E6;
    clear: both;
    float: left;
    position: relative;
    border-radius:5px;
    padding: 0px 10px 10px 10px;
  }

  .sep {
  background-color: #B1D4F9;
  height: 17px;
  }


  .tab_list{
  width: 937px;
  text-align: left;
  color: #000000;
  font-family: Arial;
  text-decoration: none;
  display: none;
  float: left;
  background-color: #E6E6E6;
  font-size: 15px;
  clear: both;
  position: relative;
  border-radius:5px;
  padding: 0px 0px 0px 5px;
  }


  .tab_header {
  border-bottom: 1px solid black;
  width: 175px;
  padding: 7px;
  }

  .tab_col {
    padding: 7px 30px 7px 30px;
    background-color: #B1D4F9 !important;
  }

  .seq {
  font-family: Monospace;
  font-size: 15px;
  }

  .Cluster_results {
  margin-top: 3px;
  width: auto;
  heigth: 80px;
  border: 1px;
  position: relative;
  padding: 1px;
  font-size: 13px;
  margin-top: 20px;
  text-align: center;
  color: #ffffff;
  background:#cc0000;
  border-radius:5px;
  cursor: pointer;
  float: left;
  clear: both;
  display: none;
  }

  .Cluster_results:active {
  position:relative;
  top:1px;
  }

  .icon {
    margin: 17px;
  }

  .Section_button {
  background-color: '.$blue_color.';
  float: left;
  margin-top: 0px;
  margin-bottom: 0px;
  width: 450px;
  height: 20px;
  position: relative;
  display: block;
  text-align: center;
  color: '.$blue_font_color.';
  font-size: 15px;
  padding: 1px;
  clear: both;
  border-radius:5px;
  cursor: pointer;
  }

  .file_link {
  cursor: pointer;
  text-decoration: none;
  }

  .file_link:hover {
  text-decoration: underline;
  }

  #hclust_tree_head {
  width: 900px;
  heigth: 400px;
  margin-top: 15px;
  margin-bottom: 5px;
  display: inline-block;
  position: relative;
  padding: 3px;
  background-color: #B1D4F9;
  float: left;
  border-radius:5px;
  font-size: 12px;
  clear: both;
  }

  .logo {
	position: relative;
	max-width: 100%;
	max-height: 13%;
	width: 120px;
	height: 65px;
	float: left;
	clear: both;
  }

  .logo_tab {
	position: relative;
	max-height: 20%;
	height: 45px;
	width: 75px
	float: left;
	clear: both;
  }

  .logo_tree {
  position: relative;
  float: left;
  display: none;
  clear: both;
  padding: 0px;
  }

  .branch_motifs_head {
  width: 950px;
  heigth: 500px;
  margin-top: 15px;
  margin-bottom: 5px;
  display: none;
  position: relative;
  padding: 3px;
  background-color: #B1D4F9;
  float: left;
  border-radius:5px;
  font-size: 12px;
  clear: both;
  }

  .spacer {
  heigth: 200px;
  display: block;
  position: relative;
  clear: both;
  float: left;
  background-color: #B1D4F9;
  }


  .tab_spacer_1 {
  padding: 2px 12px 2px 12px;
  font-size: 12px;
  }


  .tab_spacer_2 {
    padding: 3px;
    font-size: 12px;
  }

  #heatmap {
	heigth: 400px;
	width: 450px;
  }

  #show_forest {
	heigth: auto;
	width: 97%;
	position: relative;
	float: left;
	clear: both;
	border-radius:5px;
  }

  .display_clusters{
    width: 1100px;
    background-color: #E6E6E6;
    text-align: center;
    padding: 0px 10px 10px 10px;
  }

  .par_text {
    font-size: 12px;
    text-align: center;
  }

  .sep_clusters_div {
    clear: both;
    float: left;
    display: block;
  }

  .display{
	height: auto;
	width: 1000;
	border-radius: 5px;
	background-color: #FFFFFF;
	margin: 10px;
        padding: 7px;
	text-align: left;
	border: solid 3px #004F72;
	clear: both;
	position: relative;
	float: left;
	display: block;
  }

  .individual_results{
	text-align:center;
	padding: 0px 10px 0px 20px;
	width: auto;
	height: auto;
	border-radius: 10px;
	background-color: #E6E6E6;
        position: relative;
        clear: both;
        margin: 0px 7px 7px 0px;
        display: block;
        float: left;
  }

  .cluster_info_head {
	background-color: #DCE4EC;
	float: left;
	height: 45px;
	width: 630px;
	position: relative;
	display: block;
	text-align: left;
	color: #34373B;
	font-size: 15px;
	padding: 0px;
	border-radius:5px;
	clear: both;
        margin-top: 5px;
  }

  .hide_show_button{
	float: left;
	margin: 5px 3px 3px 3px;
	width: 75px;
	height: 15px;
	position: relative;
	display: inline-block;
	text-align: center;
	color: #34373B;
	font-size: 12px;
	padding: 4px;
	cursor: pointer;
	border-radius:5px;
  }

  #show_all_button{
     background-color: '.$orange_color.';
     border: 1px solid orange;
     color: '.$font_color.';
  }

  #hide_all_button{
    background-color: '.$blue_color.';
    border: 1px solid #819FF7;
     color: '.$font_color.';
  }

  .selected_cluster {
    background-color: '.$orange_color.';
    border: 1px solid orange;
  }

  .selected_header_section {
    color : '.$font_color.';
    background-color: '.$orange_color.' !important;
    border: 1px solid '.$orange_color.';
  }

  #end_report {
  width: 977px;
  heigth: 400px;
  margin-top: 15px;
  margin-bottom: 5px;
  display: inline-block;
  position: relative;
  padding: 3px;
  background-color: #E6E6E6;
  float: left;
  border-radius:5px;
  font-size: 12px;
  clear: both;
  }

  /****************/
  /* D3 CSS sytle */
  /****************/

  div {
  border-radius: 0.5px;
  }


  table {
  border: #2377D2;
  }


  .node circle {
  stroke-width: 0.5px;
  }


  .node {
  font: 10px sans-serif;
  }


  .link {
  fill: none;
  stroke-width: 1px;
  }

  svg {
  pointer-events: all;
  background-color: white;
  overflow: scroll;
  }

  .param {
  font: 11px sans-serif;
  }

</style>
';

    return($CSS_mat_clus);
}

###########################################
## PArameters table of matrix-clustering.
## The values are filled with variables
## taken from other parts of the code
sub ParametersTable{

  #my $hclust_method_link = "http://pedagogix-tagc.univ-mrs.fr/courses/statistics_bioinformatics/pdf_files/09.clustering.pdf";

  #my $threshold_values_html = "";

  ### Print the thresholds and their values
  #foreach my $par (sort keys %lth) {
  #  $threshold_values_html .= "<strong>".$par."</strong> = ".$lth{$par}."<br>";
  #}
  #foreach my $par (sort keys %uth) {
  #  $threshold_values_html .= "<strong>".$par."</strong> = ".$uth{$par}."<br>";
  #}


  my $par_table = '
  <!-- Div with the table of selected parameters -->
  <!--  <div id="Par_tab_button" class="button_click Section_button selected_header_section"><strong>Results Summary</strong></div> -->
  <div id="Par_tab" class="tab" style="margin-bottom:15px;">
    <h2 style="margin-top: 0px;margin-bottom: 5px;">Results Summary</h2>

    <table id="parameters_table" style="width:700px;">

      <thead>

        	<tr>
        	  <th class="tab_col">Input Files</th>
        	  <th class="tab_col">Results Files</th>
        	  <th class="tab_col">Complete Output Files [zip]</th>
            <th class="tab_col">Genome Assembly</th>
            <th class="tab_col"><i>matrix-scan</i> Parameters
              <table><tbody>
      	        <tr>
      	          <td class="tab_col param">Score lth</td>
                  --pval--
      	        </tr>
      	     </tbody></table>
           </th>
        	</tr>

      </thead>

      <tbody>

      	<tr>
      	  <td class="par_text"><a href="'.&RSAT::util::RelativePath($main::infile{TFs}, $main::infile{cres}).'"><strong>Download</strong></a></td>
      	  <td class="par_text"><a href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{archive}).'">Download</a></td>
          <td class="par_text"><a href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{archive}).'">Download</a></td>
          <td class="par_text">'. $main::genome .'</a></td>
          <td>
            <table span="3"><tbody>
                <td class="par_text" style="width:150px;">'. $main::score .'</td>
                --pval--
            </tbody></table>
          </td>
      	</tr>
      </tbody>

    </table>

  </div>
'."\n\n";

  if ( $main::pval ne "NA"){
    my $pval_field = "<td class=\"tab_col param\">P-value uth</td>";
    $par_table =~ s/--pval--/$pval_field/;
    $pval_field = "<td class=\"par_text\" style=\"width:150px;\">". $main::pval ."</td>";
    $par_table =~ s/--pval--/$pval_field/;
  } else {
    $par_table =~ s/--pval--//g;
  }

  print $syn $par_table;
}

###########################################
## Construct complete network's table
sub CompleteNetTable{

  my $com_net_table = '
  <!-- Div with the table of selected parameters-->
  <div id="Clus_tab_button" class="button_click Section_button"><strong>Complete Network</strong></div>
  <div id="Clus_tab" class="tab" style="margin-bottom:15px;display:none;width:auto;">
    <h2 style="margin-top: 0px;margin-bottom: 5px;">Complete Network (all genes)</h2> '."\n";

$com_net_table .= "\n".'
    <table id="cluster_summary_table" style="width:auto;">

      <thead>
      	<tr>
      	  <th class="tab_col">TF</th>
      	  <th class="tab_col">Gene</th>
      	  <th class="tab_col">Coordinates</th>
      	  <th class="tab_col">Positions</th>
      	  <th class="tab_col">Scores</th>
      	</tr>
      </thead>
      <tbody>

--main_table_html--

      </tbody>

    </table>

    <ul style="text-align:left;margin:0px 0px 5px 0px;">
       <li type="square" style="color:red">Note: by default the table displays the first (50 clusters). Click on the <i>Show X entries</i> button to display more (or less) (clusters).</li>
       <li type="square">Click on the column names to change the order of the data.</li>
       <li type="square">Use the <i>Search</i> window to find your (motif (s)) of interest.</li>
    </ul>

  </div>
'."\n\n";


  ## Insert and fill the rows
  my @rows = split(/\n/, $tables_str{complete_direct_interactions});
  my @row_fields = ();
  my $main_table_html = "";
  my $row_fields_html = "";

  while(my $com_net_row = shift(@rows) ){
    @row_fields = split(/\t/, $com_net_row);
    foreach my $field (@row_fields) {
      $row_fields_html .= "<td>". $field ."</td>"
    }
    $main_table_html .= "
      <tr>
        ".$row_fields_html."
      </tr>
    "
  }

  $com_net_table =~ s/--main_table_html--/$main_table_html/g;
  print $syn $com_net_table;

}

#########################################
## Open the <scrip> tag for JQuery code
sub OpenScriptJQuery {
  $script_jquery = '<script>

// Dynamic cluster summary table
$(document).ready( function () {
    $(\'#cluster_summary_table\').DataTable({
        "info":     true,
        "iDisplayLength": 50,
        "order": [[ 1, "asc" ]],
	"search": {
	    "regex": true,
	    "smart": true
	},
	"aoColumnDefs": [
            { "bSortable": true, "aTargets": [ 0,1,2,3,4,5,6 ] }
	]
    });
});

// Dynamic alignment table
$(document).ready( function () {
    $(\'#alignment_dyn_table\').DataTable({
        "info":     false,
        "iDisplayLength": 20,
        "order": [[ 2, "asc" ]],
	"search": {
	    "regex": true,
	    "smart": true
	},
	"aoColumnDefs": [
            { "bSortable": true, "aTargets": [ 0,1,2,3,4,5,6, ] }
	],
        "columnDefs": [ {
            "targets": -1,
            "data": null,
            "width": "5%", "targets": [0,1,2,3,4,5,6,7,8,9,10]

        } ]
    });
});

// Show all results button
$(document).ready(function() {
    $(\'#show_all_button\').click(function() {

       $(\'.branch_motifs\').show();
       $(\'.cons_tab\').show();
        $(\'.hide_show\').show();
        $(\'.cluster_division\').addClass(\'selected_cluster\');
    });
});

// Hide all results button
$(document).ready(function() {
    $(\'#hide_all_button\').click(function() {
        $(\'.hide_show\').hide();
        $(\'.cluster_division\').removeClass(\'selected_cluster\');
    });
});

// Change the color of buttons
$(document).ready(function() {

    ///////////////////
    // Hide/Show All
    $(\'#show_all_button\').mouseenter(function() {
        $(this).fadeTo(\'fast\', 0.6);
    });

    $(\'#show_all_button\').mouseleave(function() {
        $(this).fadeTo(\'fast\',1);
    });

    $(\'#hide_all_button\').mouseenter(function() {
        $(this).fadeTo(\'fast\', 0.6);
    });

    $(\'#hide_all_button\').mouseleave(function() {
        $(this).fadeTo(\'fast\',1);
    });

    /////////////////////
    // Cluster buttons
    $(\'.cluster_division\').mouseenter(function() {
        $(this).fadeTo(\'fast\', 0.6);
    });

    $(\'.cluster_division\').mouseleave(function() {
        $(this).fadeTo(\'fast\',1);
    });

    /////////////////////////////
    // Additional files button
    $(\'#List_File_Button\').mouseenter(function() {
        $(this).fadeTo(\'fast\', 0.6);
    });

    $(\'#List_File_Button\').mouseleave(function() {
        $(this).fadeTo(\'fast\',1);
    });

});


// Slide the Parameters Table
$(document).ready(function() {
    $(\'#Par_tab_button\').click(function() {
	$(\'#Par_tab\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Parameters Table
$(document).ready(function() {
    $(\'#Clus_tab_button\').click(function() {
	$(\'#Clus_tab\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Logo Forest Link
$(document).ready(function() {
    $(\'#Logo_Forest_button\').click(function() {
	$(\'#show_forest\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Logo Forest Link
$(document).ready(function() {
    $(\'#Radial_Tree_Link_button\').click(function() {
	$(\'#Radial_Tree_Link\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Individual Motif View
$(document).ready(function() {
    $(\'#Motif_Tab_button\').click(function() {
	$(\'#Motif_Tab\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Individual Cluster View
$(document).ready(function() {
    $(\'#Cluster_Tab_button\').click(function() {
	$(\'#Cluster_Tab\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Heatmap View
$(document).ready(function() {
    $(\'#Heatmap_button\').click(function() {
	$(\'#Heatmap_view\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the Heatmap View
//$(document).ready(function() {
//    $(\'#Motif_richness_button\').click(function() {
//	$(\'#Motif_richness\').slideToggle(\'fast\');
//        $(this).toggleClass(\'selected_header_section\');
//    });
//});

// Slide the Motif per clusters View
//$(document).ready(function() {
//    $(\'#Heatmap_motifs_button\').click(function() {
//	$(\'#Heatmap_motifs\').slideToggle(\'fast\');
//        $(this).toggleClass(\'selected_header_section\');
//    });
//});

// Slide the Collections Complementarity View
//$(document).ready(function() {
//    $(\'#Heatmap_complementarity_button\').click(function() {
//	$(\'#Heatmap_complementarity\').slideToggle(\'fast\');
//        $(this).toggleClass(\'selected_header_section\');
//    });
//});

// Slide the File list
$(document).ready(function() {
    $(\'#List_Files_Button\').click(function() {
	$(\'#File_list\').slideToggle(\'fast\');
        $(this).toggleClass(\'selected_header_section\');
    });
});

// Slide the References
$(document).ready(function() {
  $(\'#References_Button\').click(function() {
	   $(\'#end_report\').slideToggle(\'fast\');
     $(this).toggleClass(\'selected_header_section\');
  });
});
';
}


###########################################
## Insert the JQuery script in the report
sub InsertJquery {
    print $syn $script_jquery;
}


#######################################
## Insert the list of files exported
sub InsertListOfFiles {

      my $add_files =
	  '

    <div id="List_Files_Button" class="button_click Section_button" style="margin-top:5px;margin-bottom:4px;"><strong>Individual Files</strong></div>
  	<div id="File_list" class="tab_list" style="width:960px">

	  <table>

	    <thead>
	      <tr>
      		<th class="tab_col" style="width:200px">File</th>
      		<th class="tab_col" style="width:700px">Description</th>
	      </tr>
	    </thead>

	    <tbody>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{complete_direct_interactions}).'"><strong>Complete Network</strong></a></td>
		      <td class="tab_spacer_2">This table shows the network done with all the genes for which its regulatory sequence was indicated. Format is as follows: a tf-gene interaction per row, coordinates where it was found, strand and position starting from first coordinate and <em>matrix-scan</em>s related score.</td>
		   </tr>
	    </tbody>

	  </table>

	</div>
';

      print $syn $add_files;
}

################################################################
## Generate a HTML report summarizing the main results with
## links to the original result files.
sub Synthesis {

    &RSAT::message::TimeWarn("\n; Generating HTML Report") if ($main::verbose >= 2);

    &ReOpenSynthesis();

    ## Initialize the variables
    ## /* to delete? */
    #%ids_to_cluster = ();
    #%alignment_table_data = ();
    #%alignment_size = ();
    ## /* ? */
    $script_jquery = "";
    ## /* to delete? */
    #$all_d3_trees = "";
    #$all_consensus_table = "";
    #$number_of_motifs = 0;
    #$nb_char = 0;
    ## /* ? */
    my $section_tab_icon_tail = '</td></tr>';
    my $section_tab_icon_intermediate = '</td></tr><tr><td>';
    my $section_tab_icon_tail_int_table = '</td></tr></table></td></tr>';
    my $icon_height = 60;

    $menu_nb = 200; ## Numbering of the IDs for collapsible elements ## /* to delete? */

    #&ReadAlignmentTable();

    ## /* to delete? */
    #$number_of_clusters = scalar(keys %alignment_table_data);
    #
    #if ($radial_tree_flag == 1){
	  #   &create_html_radial_tree_file();
    #} else {
	  #   &create_html_small_tree_file();
    #}
    ## /* ? */

    &OpenScriptJQuery();

    &ReportStyleCSS();

    &ParametersTable();

    #################################
    ##       ICONS SECTION        ##
    #################################

    ## Open the icons table
    my $table_icons_head = '<table style="display:block;clear:both;"><tbody>';
    print $syn $table_icons_head;

    #################################
    ##  Main networks

    my $net_icon = '
          <tr>
            <td><img class="icon" src="'.$icons{network}.'" height="'.$icon_height.'", width="auto"></td>
            <td>
              <table>
                <tr>
                <td>';
    print $syn $net_icon;

    &CompleteNetTable;

    print $syn $section_tab_icon_tail_int_table;

    ## Close the icons table
    my $table_icons_tail = "</tbody></table>";
    print $syn $table_icons_tail;

    #################################
    #################################

    &InsertListOfFiles();

    &InsertJquery();

    #if ($radial_tree_flag == 1){
	     print $syn "</script>\n";
    #}

    &Text_end_report();

    ## End of the HTML file
    &CloseSynthesis();

    &RSAT::message::TimeWarn("Report", $main::outfile{summary}) if ($main::verbose >= 2);
}
