#!/usr/bin/env perl

require "RSA.stat.lib";
require RSAT::pattern;

package main;

## initialization
$accepted_input_seq{'tab'} = 1;
$accepted_input_seq{'raw'} = 1;
$accepted_input_seq{'multi'} = 1;
$accepted_input_seq{'ig'} = 1;
$accepted_input_seq{'wconsensus'} = 1;
$accepted_input_seq{'wc'} = 1;
$accepted_input_seq{'fasta'} = 1;
$accepted_input_seq{'filelist'} = 1;
$accepted_input_seq{'gcg'} = 1;
$accepted_input_seq{'ncbi'} = 1;
$accepted_input_seq{'genbank'} = 1;
$accepted_input_seq{'embl'} = 1;
$accepted_input_seq{'maf'} = 1;
$accepted_input_seq{'ft'} = 1;
$accepted_input_seq = join ",", sort keys %accepted_input_seq;

$accepted_output_seq{'raw'} = 1;
$accepted_output_seq{'tab'} = 1;
$accepted_output_seq{'multi'} = 1;
$accepted_output_seq{'ig'} = 1;
$accepted_output_seq{'wconsensus'} = 1;
$accepted_output_seq{'wc'} = 1;
$accepted_output_seq{'fasta'} = 1;
$accepted_output_seq{'fastq'} = 1;
$accepted_output_seq{'ft'} = 1;
$accepted_output_seq{'filelist'} = 1;
$accepted_output_seq = join ",", sort keys %accepted_output_seq;


################################################################
## extracts a substring but checks limits
sub sub_sequence {
    my ($sequence, $offset, $len) = @_;

    my $seq_len = length($sequence);

    if ($offset > $seq_len -1) {
	return "";
    }

    if ($offset < 0) {
	$len += $offset;
	$offset = 0;
    } elsif ($offset + $len > $seq_len) {
	$len = $seq_len - $offset;
    }
    my $result = substr($sequence, $offset, $len);
    return ($result);
}

################################################################
## based on the IUPAC code for partly specified nucleotides
##	A			(Adenine)
##	C			(Cytosine)
##	G			(Guanine)
##	T			(Thymine)
##	R	= A or G        (puRines)
##	Y	= C or T        (pYrimidines)
##	W	= A or T        (Weak hydrogen bonding)
##	S	= G or C        (Strong hydrogen bonding)
##	M	= A or C        (aMino group at common position)
##	K	= G or T        (Keto group at common position)
##	H	= A, C or T     (not G)
##	B	= G, C or T     (not A)
##	V	= G, A, C       (not T)
##	D	= G, A or T     (not C)
##	N	= G, A, C or T  (aNy)
sub InitMatchScores {
    my %matching_residues = ();

    ## Matches between non-ambiguous nucleotides
    my @nucleotides = qw (A C G T);

    ## Matches between nucleotides and IUPAC
    my %IUPAC = &IUPAC();
    my @IUPAC = keys %IUPAC;
    foreach my $d1 (@IUPAC) {
	foreach my $d2 (@IUPAC) {
	    next if ($d2 gt $d1); ## Already treated since the match is reciprocal
	    my @match1 = @{$IUPAC{$d1}};
	    $match1 = scalar(@match1);

	    my @match2 = @{$IUPAC{$d2}};
	    $match2 = scalar(@match2);

	    $match{$d1}{$d2} = 0; ## initialization
	    $match{$d2}{$d1} = 0; ## initialization
	    R1: foreach my $r1 (@match1) {
		R2: foreach my $r2 (@match2) {
		    if ($r1 eq $r2) {
			my $max_match = &max($match1, $match2);
			my $min_match = &min($match1, $match2);
			$match{$d2}{$d1} = $match{$d1}{$d2} = &sum_of_hypergeometrics($match1, 4, $match2, 1, $min_match);

			warn join("\t", "match", $d1, $r1, $d2, $r2, $max_match, $min_match, $match{$d2}{$d1}, $match{$d2}{$d1}), "\n" if ($main::verbose >= 10);
			last R1;
		    }
		}
	    }
	}
    }


    return %match;
}

################################################################

=pod

=item MaxMatchingWeight

Calculate the maximal matching weight returned by CountMatches() for a
given pattern

usage:
   ($max_weight, $top_matching_seq) = &MaxMatchingWeight($seq1);

=cut

sub MaxMatchingWeight {
    my ($seq) = @_;
    my $expanded_seq = &ExpandSeq($seq);
    my %IUPAC = &IUPAC();
    my $top_matching_seq = "";
    my $len = length($expanded_seq);
    foreach my $offset (0..$len-1) {
	my $base = uc(substr($expanded_seq,$offset,1));

	my @match = @{$IUPAC{$base}}; ## set of matching residues

	## For the time begin, I just take the first matching
	## residue. In a later version, I will use the residue with
	## the lowest prior probability
	$top_matching_seq .= $match[0];
#	&RSAT::message::Debug (";base: ",$base," matches: ",@match, "\t", $top_matching_seq,"\n");

    }

#    &RSAT::message::Debug(";seq: ",$seq, $expanded_seq," top_seq: ",$top_matching_seq) if ($main::verbose >= 10);
    my ($matches,$max_weight, $proba, $length) = &CountMatches($expanded_seq,$top_matching_seq);
    #warn join"\t",";CountMatches() results",$matches,$max_weight, $proba, $length,"\n";
    return ($max_weight,$top_matching_seq);
}




################################################################

=pod

=item CountMatches($seq1, $seq2)


returns the number of matching positions between two sequences
of same length

usage:
   ($matches,$weight, $proba, $length) = &CountMatches($seq1,$seq2);

IUPAC degenerate codes are accepted for the first as well as the
second sequences.

The weight is in base units, i.e.  each unit correspond to one
perfectly specified base it is calculated from the matching
probability:

      weight = -log4(proba)
=cut

sub CountMatches {
    my ($seq1, $seq2) = @_;
    my $matches = 0;
    my $proba = 1;
    my $len1 = length($seq1);
    my $len2 = length($seq2);
    my $weight = "Inf";
#    my $weight = 0;
    my $length = &min($len1, $len2);
    foreach my $offset (0..$length-1) {
	my $base1 = uc(substr($seq1,$offset,1));
	my $base2 = uc(substr($seq2,$offset,1));
	if ($match{$base1}{$base2}) {
	    $matches++;
	    $proba *= $match{$base1}{$base2};
	}
    }
    if ($proba > 0) {
	$weight = abs(log($proba))/log(4);
    }
    return ($matches, $weight, $proba, $length);
}

################################################################

=pod

=item &BestMatch($seq1, $seq2);

Return the best match between two patterns or sequences by sliding one
sequence against another, and calculating the matching score for each
offset. The matching score is the weight returned &CountMatches().

usage:
    my ($match, $weight, $proba, $length, $best_offset, $n_offsets) = &BestMatch($seq1, $seq2);

=cut
sub BestMatch {
    my ($seq1, $seq2, %args) = @_;
    my $len1 = length($seq1);
    my $len2 = length($seq2);
    my $min_offset = -$len2+1;
    my $max_offset = $len1 -1;
    my $n_offsets = $max_offset - $min_offset + 1;
    my $best_matches = -1;
    my $best_weight = -1;
    my $best_proba = -1;
    my $best_offset;

    for my $offset ($min_offset..$max_offset) {
	my $of1 = 0;
	my $of2 = 0;
	if ($offset < 0) {
	    $of2 = -$offset; ## truncate left side of seq2
	} elsif ($offset > 0) {
	    $of1 = $offset; ## truncate left side of seq1
	}
	$sub1=substr($seq1, $of1);
	$sub2=substr($seq2, $of2);
	my ($matches, $weight, $proba, $length) = &CountMatches($sub1, $sub2);
	if ($weight > $best_weight) {
	    $best_matches = $matches;
	    $best_weight = $weight;
	    $best_proba = $proba;
	    $best_length = $length,
	    $best_offset = $offset;
	}
	warn join ("\t", $offset, $of1, $sub1, $of2, $sub2, $weight), "\n" if ($main::verbose >= 10);
    }
    warn join ("\t", $seq1, $seq2, $best_matches, $best_weight, $best_proba, $best_length, $best_offset), "\n" if ($main::verbose >= 5);
    return ($best_matches, $best_weight, $best_proba, $best_length, $best_offset, $n_offsets);
}

################################################################

=pod

=item  &CountMismatches($seq1,$seq2,$max);

Return the number of non-matching positions between two sequences of
same length, up to the maximum allowed value $max.  IUPAC degenerate
codes is supported for the first as well as the second sequence.

usage:
   $mismatches = &CountMismatches($seq1,$seq2,$max);


=cut
sub CountMismatches {
    my ($seq1,$seq2,$max) = @_;
    my $mismatches = 0;

    my $len1 = length($seq1);

    foreach my $offset (0..$len1-1) {
	my $base1 = uc(substr($seq1,$offset,1));
	my $base2 = uc(substr($seq2,$offset,1));
	unless ($match{$base1}{$base2}){
	    $mismatches++;
	    if ($mismatches > $max) {
		return $mismatches;
	    }
	}
    }
    return $mismatches;
} ### CountMismatches


################################################################

=pod

=item  &NextMatch($input_seq, $pattern,$allowed_subst,$offset);

Return the next matching position given an input sequence and a
pattern. Substitutions are allowed, and an offset can be introduced to
start searching from an abitrary position. If no match is encountered,
-1 is returned. IUPAC degenerate codes is supported for the pattern as
well as the input sequence.

usage:
    ($match_pos,$match_seq,$mismatches) = &NextMatch($input_seq, $pattern,$allowed_subst,$offset);

=cut

sub NextMatch {
    my ($input_seq, $pattern, $allowed_subst, $offset) = @_;
    $input_seq = uc($input_seq);
    $pattern = uc($pattern);
    my $pattern_len = length($pattern);
    my $last_pos =  length($input_seq) - $pattern_len;
    my $min = $pattern_len - $allowed_subst;
    my $mismatches = 0;
    for $pos ($offset..$last_pos) {
	$sub_seq = substr($input_seq,$pos,$pattern_len);
	$mismatches = &CountMismatches($sub_seq,$pattern,$allowed_subst);
	if ($mismatches <= $allowed_subst) {
	    $match_pos = $pos+1;
	    $match_seq = $sub_seq;
	    return($match_pos,$match_seq,$mismatches);
	}
    }
    return(-1);
} ### NetxMatch

################################################################
## DNA sequence substitutions
## usage
## %subst_hash = Substitute($pattern, $allowed_subst, $IUPAC_output);
###
## returns a hash of DNA sequences matching $pattern
## with >= $allowed_subst substitutions
## the keys of the hash are the matching patterns,
## the values give the number of substitutions
sub Substitute {
    local($l_pattern) = uc($_[0]);
    local($l_allowed_subst) = $_[1];
    local($l_IUPAC_output) = $_[2];
    local($l_pattern_length) = length($l_pattern);
    local($s);
    local($pos);
    local($subst_nucl);
    local(@new_patterns);
    local(@last_patterns);
    local(%l_subst);
    local($nucl);
    local($new_p);

    if ($l_IUPAC_output) {
	@{$not{'A'}} = ('b');
	@{$not{'C'}} = ('d');
	@{$not{'G'}} = ('h');
	@{$not{'T'}} = ('v');
	@{$not{'R'}} = ('y');
	@{$not{'Y'}} = ('r');
	@{$not{'W'}} = ('s');
	@{$not{'S'}} = ('w');
	@{$not{'M'}} = ('k');
	@{$not{'K'}} = ('k');
	@{$not{'H'}} = ('g');
	@{$not{'B'}} = ('a');
	@{$not{'V'}} = ('t');
	@{$not{'D'}} = ('c');
	@{$not{'N'}} = ();
    } else {
	@{$not{'A'}} = ('c','g','t');
	@{$not{'C'}} = ('a','g','t');
	@{$not{'G'}} = ('a','c','t');
	@{$not{'T'}} = ('a','c','g');
	@{$not{'R'}} = ('c','t');
	@{$not{'Y'}} = ('a','g');
	@{$not{'W'}} = ('c','g');
	@{$not{'S'}} = ('a','t');
	@{$not{'M'}} = ('g','t');
	@{$not{'K'}} = ('a','c');
	@{$not{'H'}} = ('g');
	@{$not{'B'}} = ('a');
	@{$not{'V'}} = ('t');
	@{$not{'D'}} = ('c');
	@{$not{'N'}} = ();
    }

    $l_subst{$l_pattern} = 0;
    @last_patterns = ($l_pattern);

    for $s (1..$l_allowed_subst) {
	@new_patterns = ();
	foreach $p (@last_patterns) {
	    for $pos (0..$l_pattern_length-1) {
		$nucl = substr($p,$pos,1);
		foreach $subst_nucl (@{$not{$nucl}}) {
		    if ($pos == 0) {
			$subst_pattern = "";
		    } else {
			$subst_pattern = substr($p,0,$pos);
		    }
		    $subst_pattern .= $subst_nucl;
		    $subst_pattern .= substr($p,$pos+1,$l_pattern_length - $pos) unless ($pos == $l_pattern_length);
		    @new_patterns = (@new_patterns, $subst_pattern);
		}
	    }
	}
	foreach $new_p (@new_patterns) {
	    $l_subst{$new_p} = $s;
	}
	@last_patterns = @new_patterns;
    }
    return(%l_subst);
}


## From a list of nucleotides, return the corresponding IUPAC degenerate
## based on the IUPAC code for partly specified nucleotides
##	A			(Adenine)
##	C			(Cytosine)
##	G			(Guanine)
##	T			(Thymine)
##	R	= A or G        (puRines)
##	Y	= C or T        (pYrimidines)
##	W	= A or T        (Weak hydrogen bonding)
##	S	= G or C        (Strong hydrogen bonding)
##	M	= A or C        (aMino group at common position)
##	K	= G or T        (Keto group at common position)
##	H	= A, C or T     (not G)
##	B	= G, C or T     (not A)
##	V	= G, A, C       (not T)
##	D	= G, A or T     (not C)
##	N	= G, A, C or T  (aNy)
## usage:
## $deg_nucl = &degererate_nucleotide(@nucleotides);
## input nucleotides can themslve be compltely or partly spcified
# sub degenerate_nucleotide {
#     my @nucleotides = lc(@_);
#     my $deg_nucl;
#     my %signature = ();
#     @{$signature{a}} = ('a');
#     @{$signature{c}} = ('c');
#     @{$signature{g}} = ('g');
#     @{$signature{t}} = ('t');
#     @{$signature{r}} = ('a','g');
#     @{$signature{y}} = ('c','t');
#     @{$signature{w}} = ('a','c');
#     @{$signature{s}} = ('c','g');
#     @{$signature{m}} = ('a','c');
#     @{$signature{k}} = ('g','t');
#     @{$signature{h}} = ('a','c','t');
#     @{$signature{b}} = ('c','g','t');
#     @{$signature{v}} = ('a','c','g');
#     @{$signature{d}} = ('a','g','t');
#     @{$signature{n}} = ('a','c','g','t');
#     my %pure_nucleotides = ();

# #    foreach my $i (@nucelotides) {
# #	foreach $pure @{$signature{$l}} {
# #	    #
# #	}
# #    }


#     return $deg_nucl;
# }


## usage
## %ins_hash = Insert($pattern, $allowed_ins, $IUPAC_output)
## returns a hash of DNA sequences matching $pattern
## with >= $allowed_ins insertions
## the keys of the hash are the matching patterns,
## the values give the number of insertions
sub Insert {
    local($l_pattern) = uc($_[0]);
    local($l_allowed_ins) = $_[1];
    local($l_IUPAC_output) = $_[2];
    local($l_pattern_length) = length($l_pattern);
    local(@to_insert) = ();
    local(@inserted) = ($l_pattern);
    local(%inserted);
    $inserted{$l_pattern} = 0;

    if ($l_IUPAC_output) {
	@insertable_nucl = (N);
    } else {
	@insertable_nucl = (A,C,G,T);
    }


    for $ins (1..$allowed_ins) {
	@to_insert = @inserted;
	@inserted = ();
	foreach $pat (@to_insert) {
	    for $pos (0..$l_pattern_length) {
		foreach $nucl (@insertable_nucl) {
		    if ($pos == 0) {
			$inserted_pattern = "";
		    } else {
			$inserted_pattern = substr($pat,0,$pos);
		    }
		    $inserted_pattern .= $nucl;
		    $inserted_pattern .= substr($pat,$pos);
		    $inserted{$inserted_pattern} = $ins;
		    @inserted = (@inserted, $inserted_pattern);
		}
	    }
	}
    }

    return(%inserted);
}



## usage
## %del_hash = Delete($pattern, $allowed_del, $IUPAC_output)
## returns a hash of DNA sequences matching $pattern
## with >= $allowed_del deletions
## the keys of the hash are the matching patterns,
## the values give the number of deletions
sub Delete {

    local($l_pattern) = uc($_[0]);
    local($l_allowed_del) = $_[1];
    local($l_IUPAC_output) = $_[2];
    local($l_pattern_length) = length($l_pattern);
    local(@to_delete) = ();
    local(@deleted) = ($l_pattern);
    local(%deleted);
    $deleted{$l_pattern} = 0;

    for $del (1..$allowed_del) {
	@to_delete = @deleted;
	@deleted = ();
	foreach $pat (@to_delete) {
	    for $pos (0..$l_pattern_length-1) {
		$deleted_pattern = substr($pat,0,$pos);
		$deleted_pattern .= substr($pat,$pos+1);
		$deleted{$deleted_pattern} = $del;
		@deleted = (@deleted, $deleted_pattern);
	    }
	}
    }

    return(%deleted);
}


################################################################
## Replace the multipliers within a sequence.
##
## Example: atgn(3)gta is transformed to atgnnngta
##
## Usage
##   $exp_seq = &ExpandSeq($seq);
sub ExpandSeq {
    local($seq) = $_[0];
    local($exp_seq) = "";

    while ($seq =~ /(.)\{(\d+)\}/) {
	$exp_seq .= $`;
	for $i (1..$2) {
	    $exp_seq .= $1;
	}
	$seq = "$'";
    }
    $exp_seq .= $seq;
    return($exp_seq);

}

## transform letter repeats into a single letter followed by a multiplier
## usage
## $compressed_pattern = compress_pattern($expanded_pattern,@letters_to_compress);
## example: $compressed = &compress_pattern("aaannnnnnnccc","n");
## returns aaan{7}ccc
sub compress_pattern {
    my ($expanded_pattern,@letters_to_compress) = @_;
    my $compressed_pattern = "";
    my $epl = length($expanded_pattern);
    my $last_letter = "";
    my $current_letter = "";
    my $count = 0;
    my $letter = "";
    my %to_compress;

    $expanded_pattern = lc($expanded_pattern);
    if ($#letters_to_compress > -1) {
	foreach $letter (@letters_to_compress) {
	    $to_compress{lc($letter)} = 1;
	}
    } else {
	$compress_all = 1;
    }

    foreach $pos (0..$epl) {
	$current_letter = substr($expanded_pattern,$pos,1);
	if (($current_letter eq $last_letter) &&
	    (($to_compress{$current_letter}) ||
	     ($compress_all))) {
	    $count++;
	} elsif ($count > 0) {
	    $count++;
	    $compressed_pattern .= "{$count}";
	    $count = 0;
	    $compressed_pattern .= uc($current_letter);
	} else {
	    $compressed_pattern .= uc($current_letter);
	}
	$last_letter = $current_letter;
    }
    return($compressed_pattern);
}


################################################################
## Return the reverse of the IUPAC codes for ambiguous nucleotides
## Result : a hash table with a nucleotide as key and the list of
## matching ambiguous codes as value
## Usage:
##     my %revIUPAC = &ReverseIUPAC($iupac_seq);
sub ReverseIUPAC {
    my %revIUPAC = ();
    my %IUPAC = &IUPAC();
    foreach my $d (sort keys %IUPAC) {
	my @nucleotides = sort(@{$IUPAC{$d}});
	foreach my $n (@nucleotides) {
	    push @{$revIUPAC{$n}}, $d;
	}
    }
    return %revIUPAC;
}

################################################################
## Return IUPAC codes for ambiguous nucleotides
## Result : a hash table with an ambiguous code as key and the list of
## matching nucleotides as value
## Usage:
##      my %IUPAC = &IUPAC();
sub IUPAC {
    my %IUPAC = ();
    $IUPAC{A} = ["A"];
    $IUPAC{C} = ["C"];
    $IUPAC{G} = ["G"];
    $IUPAC{T} = ["T"];

    $IUPAC{R} = ["A","G"];
    $IUPAC{Y} = ["C","T"];
    $IUPAC{M} = ["A","C"];
    $IUPAC{K} = ["G","T"];
    $IUPAC{S} = ["C","G"];
    $IUPAC{W} = ["A","T"];
    $IUPAC{B} = ["C","G","T"];
    $IUPAC{D} = ["A","G","T"];
    $IUPAC{H} = ["A","C","T"];
    $IUPAC{V} = ["A","C","G"];
    $IUPAC{N} = ["A","C","G","T"];
    return %IUPAC;
}

################################################################
## Convert a DNA sequence with IUPAC ambiguous codes
## into a regular expression
sub IUPAC_to_regular {
    my ($regular) = @_;

    my %IUPAC = &IUPAC();
    foreach my $N (sort keys %IUPAC) {
	## only replace ambiguous code
	next unless (scalar(@{$IUPAC{$N}}) > 1);

	my $N = uc($N); ## make sure we have an uppercase
	my $expr_uc = uc(join "", sort(@{$IUPAC{$N}}));
	$regular =~ s/$N/[${expr_uc}]/g;

	my $n = lc($N); ## take the corresponding lowercase
	my $expr_lc = lc($expr_uc);
	$regular =~ s/$n/[${expr_lc}]/g;

# 	warn join( "\t",
# 		   $N,
# 		   $expr_uc,
# 		   $n,
# 		   $expr_lc,
# 		   join( ";", @{$IUPAC{$N}}),
# 	     ), "\n" if ($main::verbose >= 10);
    }
    return $regular;
}


################################################################
## Convert a DNA sequence with regular expressions into IUPAC
## ambiguous codes
sub regular_to_IUPAC {
    my ($regular) = @_;

    ## Ignore non-letter characters
    $regular =~ s/\.//g;
    $regular =~ s/\[\-/\[/g;

    $regular =~ s/\[(\S)\]/$1/g; ## single letter in brackets

    $regular =~ s/\[AG\]/R/g;
    $regular =~ s/\[CT\]/Y/g;
    $regular =~ s/\[AC\]/M/g;
    $regular =~ s/\[GT\]/K/g;
    $regular =~ s/\[CG\]/S/g;
    $regular =~ s/\[AT\]/W/g;
    $regular =~ s/\[CGT\]/B/g;
    $regular =~ s/\[AGT\]/D/g;
    $regular =~ s/\[ACT\]/H/g;
    $regular =~ s/\[ACG\]/V/g;
    $regular =~ s/\[ACGT\]/N/g;

    $regular =~ s/\[ag\]/r/g;
    $regular =~ s/\[ct\]/y/g;
    $regular =~ s/\[ac\]/m/g;
    $regular =~ s/\[gt\]/k/g;
    $regular =~ s/\[cg\]/s/g;
    $regular =~ s/\[at\]/w/g;
    $regular =~ s/\[cgt\]/b/g;
    $regular =~ s/\[agt\]/d/g;
    $regular =~ s/\[act\]/h/g;
    $regular =~ s/\[acg\]/v/g;
    $regular =~ s/\[acgt\]/n/g;
    return $regular;
}

################################################################
## overlap coefficient ####
## calculates the overlap coefficient, calculated following
## Pevzner et al.(1989). J. Biomol. Struct & Dynamics 5:1013-1026
## and adapted for the overlapping with reverse complement
## usage: OverlapCoeff($pattern)
## returns a value of 1 for non-overlapping patterns, and greater for
## self-overlapping patterns
sub OverlapCoeff {
    my ($word, %residue_proba) = @_;
    my $word_length = length($word);
    my $coeff = 1;
    my $rc_word = "";
    my $comp_word = "";

    ## check that nucleotide probabilities were defined
    foreach $base (sort keys %residue_proba) {
	$residue_proba_sum += $residue_proba{$base};
    }
    ## if not, assume equiprobable nucleotides
    if  ($residue_proba_sum == 0) {
	$residue_proba{'a'} = 0.25;
	$residue_proba{'c'} = 0.25;
	$residue_proba{'g'} = 0.25;
	$residue_proba{'t'} = 0.25;
    }

    ### direct overlaps
    for $i (1..$word_length-1) {
	$comp_word = substr($word,0,$i).$word;
	if ($comp_word =~ /^${word}/i) {
#	    $coeff += 0.25**$i;
            $coeff_add = 1;
	    for $offset (0..$i-1) {
		$base = lc(substr($comp_word,$offset,1));
		$coeff_add *= $residue_proba{$base};
	    }
	    $coeff += $coeff_add;
	}
    }

    ### reverse complement overlaps
    if ($sum_strands) {
	$rc_word = ReverseComplement($word);
	for $i (0..$word_length-1) {
	    $comp_word = substr($word,0,$i).$rc_word;
	    if ($comp_word =~ /^$word/i) {
#		$coeff += 0.25**$i;
		$coeff_add = 1;
		for $offset (0..$i-1) {
		    $base = lc(substr($comp_word,$offset,1));
		    $coeff_add *= $residue_proba{$base};
		}
		$coeff += $coeff_add;
	    }
	}
    }

    return($coeff);
}

################################################################
## Return the reverse complement of a DNA sequence
##
## Note: the option $case_insensitive performs a quicker conversion,
## but case information is lost (all letters are converted to
## uppercases).
##
sub ReverseComplement {
    local($orig_seq, $case_insensitive) = $_[0];
    $complement = reverse $orig_seq;
    $complement =~ tr/a-z/A-Z/;
    ### simple nucleotides
    $complement =~ s/A/t/g;
    $complement =~ s/T/a/g;
    $complement =~ s/C/g/g;
    $complement =~ s/G/c/g;
    ### degenerate code
    $complement =~ s/R/y/g;
    $complement =~ s/Y/r/g;
    $complement =~ s/M/k/g;
    $complement =~ s/K/m/g;
    $complement =~ s/B/v/g;
    $complement =~ s/V/b/g;
    $complement =~ s/H/d/g;
    $complement =~ s/D/h/g;
    #  $complement =~ s/S/s/g;
    #  $complement =~ s/W/w/g;
    #  $complement =~ s/N/n/g;
    ###  brackets
    $complement =~ s/\[/temp/g;
    $complement =~ s/\]/\[/g;
    $complement =~ s/temp/\]/g;
    $complement =~ tr/a-z/A-Z/;
    ### multiplier
    while (($complement =~ /(\}\d+\{)/)
	   || ($complement =~ /(\}\d+,\d+\{)/) ) {
	$rev_mul = reverse $1;
	$complement =~ s/$1/$rev_mul/g;
    }
    $complement =~ s/(\{\d+\})(\w)/$2$1/g;
    $complement =~ s/(\{\d+,\d+\})(\w)/$2$1/g;
    $complement =~ s/(\{\d+\})(\[\w+\])/$2$1/g;
    $complement =~ s/(\{\d+,\d+\})(\[\w+\])/$2$1/g;


    ## Restore the same lower/uppercases in the reverse complement as
    ## in the original sequence
    unless ($case_insensitive) {
      my $complement_cs = "";
      for my $offset  (1..length($orig_seq)) {
	if (substr($orig_seq, -$offset, 1) =~ /[a-z]/) {
	  $complement_cs .= lc(substr($complement, $offset -1, 1));
	} else {
	  $complement_cs .= substr($complement, $offset -1, 1);
	}
      }
      $complement = $complement_cs;
    }

    return $complement;
}# ReverseComplement


## usage
##    Palindromic($sequence)
## returns true if a sequence is palindromic, i.e., if
## it is equal to its reverse complement
sub Palindromic {
    local($seq) = lc($_[0]);
    local($rc) = lc(&ReverseComplement($seq));

    if ($seq eq $rc) {
	return 1;
    } else {
	return 0;
    }

}

################################################################
## Print one DNA sequence in various formats
## See the hash %accepted_output_seq for a list of accepted formats
## Usage:
##   PrintNextSequence(OUTFILE, $format,$line_width,$sequence,$seq_id, @comments)
## where
##       OUTFILE is a file handle
##       $format is one of the accepted formats
##       $line_width indicates the number of nucleotides beofre
##                   each carriage return
##                   a 0 value means no carriage return
##       $sequence is the sequence
##       $seq_id is an identifier for the sequence
##               (required or not depending on the format)
##       @comments is a list of comments (one element per line)
##                 comments are only supported for some formats such as
##                 IG or Wconsensus
sub PrintNextSequence {
    local($OUTFILE) =  shift;
    local($out_format) = lc(shift);
    local($line_width) = shift;
    local($sequence) = shift;
    local($seq_id) = shift;
    local(@comments) = @_;

    ### insert the carriage returns
#	if (($out_format eq "wc") || ($out_format eq "wconsensus") || ($out_format eq "multi")) {
    if (($out_format eq "multi")  
	|| ($out_format eq "ft")
	|| ($out_format eq "fastq")
	) {
	$line_width = 0;
    }
    $sequence = &FoldSequence($sequence,$line_width);

    if ($out_format eq "ig") {          ## IntelliGenetics format
	foreach $line (@comments) {
	    print $OUTFILE ";$line\n";
	}
	print $OUTFILE "$seq_id\n";
	print $OUTFILE $sequence;
	print $OUTFILE "1\n";

	## fastA format
    } elsif ($out_format eq "fasta") {
	my $first_comment = $comments[0] || "";
	print $OUTFILE  ">".$seq_id;
	if ($first_comment) {
	    print $OUTFILE "\t".$first_comment;
	}
	print $OUTFILE "\n";
	chomp($sequence);
	print $OUTFILE $sequence;
	print $OUTFILE "\n";


	## fastQ format (fake fastQ files, qualities are all set to their maximal values)
    } elsif ($out_format eq "fastq") {
	my $len = length($sequence);
	print $OUTFILE  '@', $seq_id, "\n";
	print $OUTFILE $sequence, "\n";
	print $OUTFILE "\+\n";
	print $OUTFILE "I"x$len, "\n";

	## feature format
    } elsif ($out_format eq "ft") {

	## Quick and dirty: the arguments specifically required for the ft
	## cormat are passed as coments, in a specific order.
	my $map_id= shift (@comments);
	my $seq_type= shift (@comments);
	my $strand = shift (@comments);
	my $left_end = shift (@comments);
	my $right_end = shift (@comments);
	my $comment = join ("\t", @comments);

	print $OUTFILE join ("\t",
			     $map_id,
			     $seq_type,
			     $seq_id,
			     $strand,
			     $left_end,
			     $right_end,
			     $sequence,
			     $comment,
			     ), "\n";

    } elsif (($out_format eq "wc") || ($out_format eq "wconsensus")) {     ## wconsensus format
	foreach $line (@comments) {
	    print $OUTFILE ";$line\n";
	}
	print $OUTFILE $seq_id;
	print $OUTFILE "\t";
	if ($dna_alphabet) {
	    $sequence =~ s/n/./gi;
	}
	print $OUTFILE "\\$sequence\\";
	print $OUTFILE "\n";

    } elsif ($out_format eq "tab") {
	print $OUTFILE join "\t", $seq_id, $sequence;
	my $comments = join "; ", @comments;
	if ($comments) {
	    print $OUTFILE "\t".$comments;
	}
	print $OUTFILE "\n";

    } elsif ($out_format eq "raw") {
      ## Beware: raw sequences CANNOT contain carriage return even at
      ## the end of the file, because this would create a problem with
      ## retrieve-seq: the carriage return would be counted as part of
      ## the sequence length by &RSAT::SequenceOnDisk::get_length().
      print $OUTFILE "$sequence";

    } elsif ($out_format eq "multi") {
	print $OUTFILE "$sequence\n";
    }
}


## checks whether the sequence format is supported
## Usage:
##     &CheckInputSeqFormat($format)
## Returns 1 if the format is accepted for input sequence,
## exits otherwise
sub CheckInputSeqFormat {
  local($sequence_format) = lc($_[0]);
  if ($accepted_input_seq{$sequence_format}) {
    return 1;
  } else {
    &RSAT::error::FatalError("$sequence_format: invalid format for input sequence. Supported: $accepted_input_seq");
  }
}

## checks whether the sequence format is supported
## Usage:
##     &CheckOutputSeqFormat($format)
## Returns 1 if the format is accepted for output sequence,
## exits otherwise
sub CheckOutputSeqFormat {
    local($sequence_format) = lc($_[0]);
    if ($accepted_output_seq{$sequence_format}) {
	return 1;
    } else {
	print "$sequence_format: invalid format for output sequence\n";
	exit;
    }
}

## checks that a sequence only contains letters from a to z
## usage
##    CheckFormat($sequence,$expected_format, $seq_type);
sub CheckFormat {
    my ($l_sequence, $expected_format, $seq_type) = @_;
    $expected_format = lc($expected_format);
    $expected_format = "wconsensus" if ($expected_format eq "wc");
    $expected_format = "raw" if ($expected_format eq "multi");
    $expected_format = "raw" if ($expected_format eq "filelist");
    local($apparent_format) = "";

    if (($seq_type !~ /other/i) && ($l_sequence =~ /([^a-z\s])/i)) {
	$apparent_format = "unknown";
	$problem = $1;
	$position = length($`);

	if ($l_sequence =~ /\\/) {
	    $apparent_format = "wconsensus";
	} elsif ($l_sequence =~ />/) {
	    $apparent_format = "fasta";
	} elsif ($sequence =~ /[12]$/)  {
	    $apparent_format = "IntelliGenetics";
	}

	&RSAT::error::FatalError("Input sequence $current_id is not in the expected format, or contains invalid characters for a sequence of type $seq_type.");

	exit();
    }
    return;
}

################################################################
## Reads a DNA sequence
## various formats are accepted (see the hash %accepted_raw_formats
## Usage:
## ($sequence, $seq_id, @seq_comments) = &ReadNextSequence(FILE, $seq_format, $input_dir, $seq_type, $mask)
## where
## where   FILE is a file handle
##         $format is one of the accepted sequence formats
##                 (see CheckFormat)
##         $input_dir is the input directory
##         $seq_type
##         $mask (accepted values: "upper" or "lower"). Mask upper or lowercases by replacing them by N
sub ReadNextSequence {
  my ($SEQ, $sequence_format, $input_dir, $seq_type, $mask, %args) = @_;
  $sequence_format = lc($sequence_format);

  ## Columns for the tab-delimited format
  my $id_column = $args{'id_column'} || 1;
  my $seq_column = $args{'seq_column'} || 2;
  my $comment_column = $args{'comment_column'} || 0;

  local $sequence = "";
  local $seq_id = "";
  local @comments = ();
  local @next_comments = ();

  ### single raw file ###
  if ($sequence_format eq "raw") {
    if (defined($inputfile)) {
      if ($inputfile =~ /([\S]*\/)*([\S^\/]+)$/) {
	$seq_id = $2;
      } else {
	$seq_id = $inputfile;
      }
    } else {
      $seq_id = "seq";
    }
    ;

    $sequence = "";
    while (<$SEQ>) {
      next if ((/^;/) || (/^\#/) || (/^--/));
      $sequence .= $_;
    }
    if ($sequence) {
      #	    $sequence = &FoldSequence($sequence, 0);
      #	    &CheckFormat($sequence, $sequence_format, $seq_type);
      #	    return ($sequence, $seq_id, @comments);
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    } else {
      return ("","");
    }

    ## multi: several raw sequences in the same file, separated by a newline
  } elsif ($sequence_format eq "multi") {
    $seq_counter++;
    if ((defined($inputfile)) && ($inputfile =~ /([\S]*\/)*([\S^\/]+)$/ )) {
      $seq_id = $2;
    } else {
      $seq_id = $Sequence_File;
    }
    $seq_id .= "_$seq_counter";
    $sequence = "";
    my $gotit = 0;
    while ((defined($SEQ)) && ($sequence = <$SEQ>) && !($gotit)) {
      next if ($sequence =~ /^;/);
      $gotit = 1;
      #	    $sequence = &FoldSequence($sequence, 0);
      #	    &CheckFormat($sequence, $sequence_format, $seq_type);
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    }
    return ("","") unless $gotit;

    ### file list ###
  } elsif ($sequence_format eq "filelist") {
    $found = 0;
    while (!($found)) {
      $next_line = <$SEQ> || return ("","");
      next if ($next_line =~ /^;/);	     ### skip comment lines
      if ($next_line =~ /^\s*(\S+)/) { ### make sure to take a non-empty line
	$next_file = $1;   ### file name is the first word of the line
	$found = 1;
      }
    }
    &RSAT::message::Debug("ReadNextSequence", $next_file, "input directory", $input_dir)
      if ($main::verbose >= 4);

    unless (-e $next_file) {
      if (-e ${input_dir}."/".${next_file}) {
	$next_file = "$input_dir/$next_file";
      }
    }
    if ((-e $next_file) && (open NEXT_SEQ, $next_file)) {
      warn "; Reading file $next_file\n" if ($verbose >= 4);
      ## extract the sequence file name without path ####
      my ($next_dir, $next_base) = &RSAT::util::SplitFileName($next_file);
      $seq_id = $next_base;
      $seq_id =~ s/\.raw$//;
#      if ($next_file =~ /([\S]*\/)*([\S^\/]+)$/ ) {
#	$seq_id = $2;
#      } else {
#	$seq_id = $next_file;
#      }
      $sequence = "";
      while (<NEXT_SEQ>) {
	$sequence .= $_;
      }
      close NEXT_SEQ;
      #	    $sequence = &FoldSequence($sequence, 0);
      #	    &CheckFormat($sequence, $sequence_format, $seq_type);
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    } else {
      die "\tError: cannot open sequence file $next_file\n";
    }

    ### IntelliGenetics format ###
  } elsif ($sequence_format eq "ig") {
    while (<$SEQ>) {
      if (/^;(.*)/) {
	## comment line
	@comments = (@comments, $1);
      } elsif (($seq_id eq "") && (/(\S+)\s/)) {
	## identifier for the next sequence
	$seq_id = $1;
      } elsif (/(.*)[12]/) {
	## end of the current sequence
	$sequence .= $1;
	#		$sequence = &FoldSequence($sequence, 0);
	#		&CheckFormat($sequence, "raw", $seq_type);
	return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
      } else {
	$sequence .= $_;
      }
    }
    return ("","");	     ### when input file has been totally read

    ### tab-delimited text file
  } elsif ($sequence_format eq "tab") {
    while (<$SEQ>) {
      next if (/^--/);
      next if (/^;/);
      next if (/^\#/);
      next unless (/\S/);
      chomp();
      my @fields = split "\t";
      my $seq_id = $fields[$id_column-1];
      my $sequence = $fields[$seq_column -1];
      my @comments =  ();
      if ($comment_column) {
	push @comments, $fields[$comment_column -1];
      }
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    }
    return ("","");	     ### when input file has been totally read

  } elsif ($sequence_format eq "ft") {
    while (<$SEQ>) {
      next if (/^--/);
      next if (/^;/);
      next if (/^\#/);
      next unless (/\S/);
      chomp();
      my @fields = split "\t";
      my $seq_id = $fields[2];
      my $sequence = $fields[6];
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    }
    return ("","");	     ### when input file has been totally read

    ### Wconsensus format ###
  } elsif (($sequence_format eq "wc") || ($sequence_format eq "wconsensus")) {
    while (<$SEQ>) {
      if (/^;(.*)/) {
	## comment line
	@comments = (@comments, $1);
      } elsif (($seq_id eq "") && (/(\S+)\s+\\(.*)/)) {
	$seq_id = $1;
	$the_rest = $2;
	if ($the_rest =~ /(.*)\\/) {
	  $sequence = $1;
	} else {
	  $end_of_seq = 0;
	  $sequence = $the_rest;
	  do {
	    if ($next_line = <$SEQ>) {
	      if ($next_line=~ /(.*)\\/) {
		$end_of_seq = 1;
		$sequence .= $1;
	      } else {
		$sequence .= $next_line;
	      }
	    } else {
	      return ("",""); ### when input file has been totally read
	    }
	  } until ($end_of_seq);
	}
	#		$sequence = &FoldSequence($sequence, 0);
	#		return ($sequence, $seq_id, @comments);
	return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
      }
    }
    return ("","");	     ### when input file has been totally read

    ### FastA format ###
  } elsif ($sequence_format eq "fasta") {
    while (<$SEQ>) {
      next if ((/^;/) || (/^\#/)); ## Skip comment lines (note that those comment lines are not part of the canonical fasta format)

      ## Fasta header.
      ##
      ## Slight difficulty: we have to return the previous sequence
      ## after having read the fasta header of the next sequence -> we
      ## have to keep the the previous and next ID and comment fields,
      ## and treat in a special way the first and last sequence of a
      ## file.
      if (/^\s*>\s*(\S*)\s*(.*)/) {
	my $next_id = $1; ## new sequence identifier
	@next_comments = ($2); 	## new sequence comments/description

	## Check that sequence ID is not empty
	unless ($next_id) {
	  &RSAT::message::Warning("Invalid format for a fasta file: empty sequence identifier.");
	  $empty_seq_counter++;
	  $next_id = "unidentified_seq_".$empty_seq_counter;
	}
	&RSAT::message::Debug("ReadNextSequence()","ID", $next_id) if ($main::verbose >= 4);


	if ($current_seq_id) {
	  ## New ID after a previous sequence.  Action: return the
	  ## previous sequence and hold the new ID in the variable $current_seq_id for the next
	  ## sequence
	  my $seq_id = $current_seq_id;
	  my @comments = @current_comments;
	  # &CheckFormat($sequence, "raw", $seq_type);
	  $current_seq_id = $next_id;
	  @current_comments = @next_comments;
	  return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
	} else {
	  ##  first id from the seq file
	  $current_seq_id = $next_id;
	  @current_comments = @next_comments;
	}
      } else {
	## continuation of the previous sequence: concatenate it
	$sequence .= $_;
      }
    }

    ## Return the last sequence after having completely read the file
    if ($current_seq_id) {
      #	    $sequence = &FoldSequence($sequence, 0);
      $seq_id = $current_seq_id;
      $current_seq_id = "";
      @comments = @current_comments;
      return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
    } else {
      return ("","");
    }

    ## ##############################################################
    ## maf format (multiple alignment file)
  } elsif ($sequence_format eq "maf") {
    while (<$SEQ>) {
      if (/^a\s/) {
	## Start a new alignment
      } elsif (/^s\s/) {
	&RSAT::message::Debug("New sequence", $_) if ($main::verbose >= 10);
	## Start a new sequence
	if (/^s\s+(\S+)\s+(\d+)\s+(\d+)\s+([\+\-])\s+(\d+)\s+(.+)/) {
	  my $contig = $1;
	  my $start_pos = $2;
	  my $length = $3;
	  my $strand = $4;
	  if ($strand eq "+") {
	    $strand = "D";
	  } elsif ($strand eq "-") {
	    $strand = "R";
	  } else {
	    &RSAT::message::Warning(join ("\t", "Invalid strand specification", $strand, $_));
	  }
	  my $contig_len = $5;
	  ## Aligned sequence (may contain gaps)
	  my $aligned_seq = $6;
	  ## "Desalign" the sequence, i.e. suppress gap symbols
	  my $desaligned_seq = $aligned_seq;
	  $desaligned_seq =~ s/\-//g;
	  $desaligned_seq =~ s/\.//g;

	  ## Generate sequence ID
	  my $seq_id = join ("_", $contig, $start_pos, $length, $strand, $contig_len);
	  my @comments = ();
	  push @comments, "Desaligned sequence (converted from maf file)";
	  push @comments, "contig: ".$contig;
	  push @comments, "fragment length: ".$length;
	  push @comments, "start position: ".$start_pos;
	  push @comments, "strand: ".$strand;
	  push @comments, "contig length: ".$contig_len;
	  &RSAT::message::Debug($seq_id, @comments) if ($main::verbose >= 4);

	  return(&ReturnSequence($desaligned_seq, $seq_id, $mask, @comments));
	} else {
	  &RSAT::message::Warning(join ("\t", "Invalid sequence header for maf format", $_));
	}

      }
    }

    ### GCG format ###
  } elsif ($sequence_format eq "gcg") {
    $seq_id = "";
    $sequence = "";
    @comments = ();
    $in_sequence = 0;
    while (<$SEQ>) {
      if (/^\/\/$/) {
	## end of record
	$sequence = &FoldSequence($sequence, 0);
	return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
      } elsif (/^\s*(\S+).+\.\.\s*$/) {
	## dividing line
	$seq_id = $1;
	$sequence = "";
	chomp;
	push @comments, $_;
	$in_sequence = 1;
      } elsif (($in_sequence) && (/(\d+)\s+(.+)$/)) { ### sequence
	$position = $1;
	$sequence .= $2;
      } elsif (($in_sequence == 0) && (/\S/)) {	### comment
	chomp;
	push @comments, $_;
      }
    }

    #	$sequence = &FoldSequence($sequence, 0);
    return(&ReturnSequence($sequence, $seq_id, $mask, @comments));

    ### NCBI/GENBANK format ###
  } elsif (($sequence_format eq "ncbi") ||
	   ($sequence_format eq "genbank")) {
    $seq_id = "";
    $sequence = "";
    @comments = ();
    $in_sequence = 0;

    while (<$SEQ>) {
      #  	    $l++;
      #  	    if (($verbose >= 5) && ($l%100000 == 0)){
      #  		warn "reading line $l\n";
      #  	    }
      chomp;
      if (/^\/\/$/) {		### end of record
	warn "Folding sequence $seq_id\n" if ($verbose >=3);
	#		$sequence = &FoldSequence($sequence, 0);
	warn "Read sequence $seq_id\n" if ($verbose >=3);
	return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
      } elsif ((/^ACCESSION\s+(\S+)/) ||
	       (/^LOCUS\s+(\S+)/)) {
	$seq_id = $1;
	warn "Sequence ID\t$seq_id\n" if ($verbose >= 4);
	$sequence = "";
	chomp;
	push @comments, $seq_id;
      } elsif (/^DEFINITION\s+/) { ### definition
	push @comments, "$'";
      } elsif (/^ORIGIN/) {
	&RSAT::message::Info( "Reading sequence", $seq_id) if ($verbose >= 4);
	$in_sequence = 1;
      } elsif (($in_sequence) && (/(\d+)\s+(.+)$/)) { ### sequence
	$position = $1;
	$sequence .= $2;
      }
    }

    #	$sequence = &FoldSequence($sequence, 0);
    return(&ReturnSequence($sequence, $seq_id, $mask, @comments));

    ### EMBL format ###
  } elsif ($sequence_format eq "embl") {
    $seq_id = "";
    $sequence = "";
    @comments = ();
    $in_sequence = 0;

    while (<$SEQ>) {
      chomp;
      if (/^\/\/$/) {		### end of record
	#		$sequence = &FoldSequence($sequence, 0);
	return(&ReturnSequence($sequence, $seq_id, $mask, @comments));
      } elsif (/^AC\s+(\S+);/) { ### accession number
	$seq_id = $1;
	$sequence = "";
	chomp;
	push @comments, $seq_id;
      } elsif (/^DE\s+/) {	### definition
	push @comments, "$'";
      } elsif (/^SQ\s+/) {
	$in_sequence = 1;
      } elsif (($in_sequence) && (/^(.+)\s+(\d+)\s*$/)) { ### sequence
	$position = $2;
	$sequence .= $1;
      }
    }

    #	$sequence = &FoldSequence($sequence, 0);
    return(&ReturnSequence($sequence, $seq_id, $mask, @comments));

    ### end of sequence file ###
  } else {
    return ("","");
  }
}


=pod

=item check_fasta_file

Quickly check if a fiel seems to contain fasta sequence, by selecting
the fasta header lines.

By default, the function selects all the lines 

Usage

my $fasta_header_lines = &CheckFastaFile($sequence_file, $top_lines);

Input parameters:

  $sequence_file : path of the sequence file
  $top_lines (optional) : restrict the analysis to the top lines of the file.

=cut
sub CheckFastaFile {
  my ($sequence_file, $top_lines) = @_;

  &RSAT::error::FatalError("&CheckfastaFile() function requires a sequence file.") unless ($sequence_file);
  if ($top_lines) {
    $cmd = "head -n ".$top_lines." ".$sequence_file;
    $cmd .= " | grep '^>'";
  } else {
    $cmd = "grep ''^>' ".$sequence_file;
  }
  $cmd .= " | wc -l | awk '{print \$1}'";

  $fasta_header_lines = `$cmd`;
  chomp($fasta_header_lines);
  return($fasta_header_lines);
}

################################################################

=pod

=item parse_genomic_coordinates

Parse genomic coordinates of a sequence from its ID or description.
This can be used by pattern matching programs (matrix-scan,
dna-pattern) in order to return genomic positions (i.e. relative to
chromosome start) rather than relative positions.

Usage:
 my ($seq_org, $seq_chrom, $seq_start, $seq_end, $seq_strand, $genome_format) = &parse_genomic_coordinates($seq_id, @seq_comments);

=cut
sub parse_genomic_coordinates {
  my ($seq_id, @seq_comments) = @_;
  my $comments = join("\t", $seq_id, @seq_comments);
  my $seq_org = "Undef_organism";
  my $seq_chrom  ="Undef_chrom";
  my $seq_start = 1;
  my $seq_end = 0;
  my $seq_strand = "DR";
  my $genome_format = "Unknown";
  my $browser_url = "";

#  &RSAT::message::Debug("Parsing sequence coordinates from sequence ID and comments", $comments) if ($main::verbose >= 5);

  if ($comments =~ /location: (\S+):(\S+):(\d+)\-(\d+):([DR])/) {
#  if ($comments =~ /location:/) {
    ## Parse genomic coordinates in the retrieve-seq format
    ($seq_org, $seq_chrom, $seq_start, $seq_end, $seq_strand) = ($1, $2, $3, $4, $5);
    $genome_format = "retrieve-seq";


  } elsif ($comments =~ /(\w+_\w+)-\S+.+location: chromosome:(\S+) (\d+) (\d+) ([DR])/) {
    ## Sequence format from retrieve-ensembl-seq

#  } elsif ($comments =~ /(\w+_\w+).*chromosome:(\S+)/) {
    my $chromosome;
    ($seq_org, $chromosome, $seq_start, $seq_end, $seq_strand) = ($1, $2, $3, $4, $5);
    ## Parse the fields of the EnsEMBL chromosome "name" (which contains genome ID + name + chromosome limits + strand
    if ($chromosome =~ /(\S+):(\S+):(\d+):(\d+):(\d+)/) {
      $seq_chrom = $2;
    } else {
      $seq_chrom = $chromosome;
    }
    $genome_format = "retrieve-ensembl-seq";

    $browser_url = "http://www.ensembl.org/${seq_org}/Location/View?r=${seq_chrom}:${seq_start}-${seq_end}";

  } elsif ($comments =~ /(\w+).+range=(\S+):(\d+)\-(\d+).*strand=(\S+)/) {
    ## Genomic coordinates in the UCSC format.
    $genome_format = "UCSC";
    ($seq_org,$seq_chrom, $seq_start, $seq_end, $seq_strand) = ($1, $2, $3, $4, $5);
    $seq_strand =~ s/\+/D/;
    $seq_strand =~ s/\-/R/;

  } elsif ($seq_id =~ /^(\S+):(\d+)\-(\d+)\((\S*)\)/) {
      ($seq_chrom, $seq_start, $seq_end, $seq_strand) = ($1, $2, $3, $4);

      ## Genomic coordinates in the bedtools getfasta format.
      $genome_format = "getfasta";
      $seq_strand = "D" unless ($seq_strand);

      # &RSAT::message::Debug("fasta header fields", join (":", $seq_chrom, $seq_start, $seq_end, $seq_strand)) if ($main::verbose >= 10);

  } else {
    &RSAT::message::Warning("Could not parse genomic coordinates for sequence", $seq_id, join("; ", @seq_comments));
  }

  &RSAT::message::Debug('&parse_genomic_coordinates()',
			"format:".$genome_format,
			"org:".$seq_org,
			"chrom:".$seq_chrom,
			"start:".$seq_start,
			"end:".$seq_end,
			"strand:".$seq_strand) if ($main::verbose >= 10);

  if ($genome_format eq "UCSC") {
    $seq_org =~ s/\_.*//;
    $browser_url = "http://genome.ucsc.edu/cgi-bin/hgTracks?";
    $browser_url .= "db=".${seq_org};
    $browser_url .= "&position=${seq_chrom}:${seq_start}-${seq_end}";
    #    $browser_url .= "&hgt.customText=http://redfly.ccr.buffalo.edu/ucsc/ucsc_BR0Bmd";
  }

  return ($seq_org, $seq_chrom, $seq_start, $seq_end, $seq_strand, $genome_format, $browser_url);
}


################################################################
## Check a sequence, mask cases if required, and return it
## Usage:
##    &ReturnSequence($sequence, $seq_id, $mask, @comments)
## Arguments:
##    $sequence: identifier of the sequence
##    $seq_id: identifier of the sequence
##    $mask (accepted values: "upper" or "lower"). Mask upper or lowercases by replacing them by N
sub ReturnSequence {
  my ($sequence, $seq_id, $mask, @comments) = @_;
#  &RSAT::message::Debug("SEQUENCE", $sequence) if ($main::verbose >= 10);
#  die "HELLO";

  $sequence = &FoldSequence($sequence, 0);
  if ($mask) {
    &CheckMask($mask);
    if ($mask eq "lower") {
      $sequence =~ s/[a-z]/N/g;
    } elsif ($mask eq "upper") {
      $sequence =~ s/[A-Z]/n/g;
    } elsif ($mask eq "non-dna") {
      $sequence =~ s/[^acgt\|]/n/gi;
#    } else {
#      $sequence =~ s/\-/n/;
#      $sequence =~ s/\./n/;
    }
  }
  return($sequence, $seq_id, @comments);
}

################################################################
## Check that the mask case option is valid
sub CheckMask {
  my ($mask) = @_;
  my %supported_mask = ("lower"=>1,
			"upper"=>1,
			"non-dna"=>1);
  my $supported_mask = join(",", sort (keys(%supported_mask)));
  unless ($supported_mask{$mask}) {
    &RSAT::error::FatalError(join("\t", $mask, "Invalid value for the mask parameter. Supported", $supported_mask));
  }
}

## ##############################################################
## Read a multiple sequence file,
## according to the output format from PILEUP (GCG package)
####
## Usage:
## ======
## %seq_hash = ReadMsf(FILE);
####
sub ReadMSF {
  local $SEQ = $_[0];
  local(%seq_hash);
  local($id);
  local($started) = 0;

  while (<$SEQ>) {
    if (/\/\//) {
      $started = 1;
    } elsif (/^\s*(\d+)\s+(\d+)\s+$/) {
           ### position
	} elsif (($started) && (/(\S+)\s+(.+)/)) {
	    $id = $1;
	    $seq_hash{$id} .= $2;
	}
    }
    foreach $id (keys %seq_hash) {
	$seq_hash{$id} =~ s/\s//g;
    }
  return %seq_hash;
}

################################################################
## Fold sequence
## usage &FoldSequence($sequence, $line_width)
## remove all blank spaces from a sequence,
## and insert return carriages every $l characters
## no carriage return is inserted if $l = 0
sub FoldSequence {
    my ($in_seq, $lw) = @_;
    my $out_seq = $in_seq;
    $out_seq =~ s/\s+//g;  ### remove blank spaces, tabs and newlines

    ## insert newline characters for output ####
    if ($lw > 0) {
      $out_seq =~ s/(\S{$lw})/$1\n/g;
    }
    return $out_seq;
}

################################################################
## CleanDna
## usage &CleanDNA($sequence, $mask_char)
## replaces all non-acgt characters by "n"
sub CleanDNA {
  my ($_sequence, $mask_char) = @_;
  $mask_char = "n" || $mask_char;
  $_sequence =~ s/\s//g;  ### remove blank spaces, tabs and newlines
  $_sequence =~ s/[^acgt]/${mask_char}/ig;  ### remove blank spaces, tabs and newlines
  return $_sequence;
}

## usage : $dist = EditDistance($string1,$string2);
## usage : $dist = EditDistance($string1,$string2,1); ### hyperverbose
## usage : $dist = EditDistance($string1,$string2,1,1); ### case sensitive
## $main::hyperverbose -> print matrix
sub EditDistance {
    use strict;
    my ($string1,$string2,$hyperverbose, $cs) = @_;
    my @dist = ();
    unless ($cs) {
	$string1 = lc($string1);
	$string2 = lc($string2);
    }
    my $len1 = length($string1);
    my $len2 = length($string2);
    my %weight = ();
    my $i = 0;
    my $j = 0;

    my @l1 = split "", $string1;
    my @l2 = split "", $string2;
    my @prev_line = ();
    my @current_line = ();

    ### initialization
    $weight{substitution} = 1;
    $weight{insertion} = 1;
    $weight{deletion} = 1;
    $weight{end_space} = 0; ### Gusfield p 228-229

    $current_line[0] = 0;
    for $j (1..$len2) {
	$current_line[$j] = $current_line[$j-1] + $weight{end_space};
    }

    if ($hyperverbose) {
	warn "- - ", join(" ",@l2), "\n";
	warn "- ", join(" ",@current_line), "\n";
    }

    ### run trhough the array and calculate distance
    for $i (1..$len1) {
	@prev_line = @current_line;
	@current_line = (); ### empty current line

	$current_line[0] = $prev_line[0] + $weight{end_space};
	for $j (1..$len2) {
	    my $match = $prev_line[$j-1];

	    $match += $weight{substitution} unless ($l1[$i-1] eq $l2[$j-1]);

	    ($current_line[$j]) = sort {
		$a <=> $b } (
			     $prev_line[$j] + $weight{insertion},
			     $current_line[$j-1] + $weight{deletion},
			     $match
			     );
	}
	warn ($l1[$i-1], " ", join(" ",@current_line), "\n")
	    if ($hyperverbose);
    }

    return $current_line[$len2]; ### this is the edit distance
}



################################################################
## Return an array with all possible oligomers of the specified length, with a given alphabet.
## Usage : &all_oligos($length, @alphabet);
##
sub all_oligos {
  my ($len, @alphabet) = @_;
  my @oligos = ();
  if  ($len == 1) {
    @oligos = @alphabet;
  } elsif ($len > 1) {
    my @sub_oligos = &all_oligos($len-1, @alphabet);
    foreach my $letter (@alphabet) {
      foreach my $oligo (@sub_oligos) {
	push @oligos, $letter.$oligo;
      }
    }
  }
  &RSAT::message::Info("&all_oligos()", "len", $len, "alphabet", scalar(@alphabet), "oligos", scalar(@oligos)) if ($main::verbose >= 4);
  return @oligos;
}


################################################################
# Read patterns from a file (or from the standard input)
# and returns a list of RSAT::pattern objects.
#
sub ReadPatterns {
  my (%args) = @_;
  my @patterns = ();
  my $pattern_file = $args{pattern_file};
  $score_column = $args{score_column};
  my $cluster_column = $args{cluster_column};
  my $noid = $args{noid};
  my $pattern_id = $args{pattern_id};
  my $pattern_score = $args{pattern_score};
  my $pattern_seq = $args{pattern_seq};
  my $pattern_cluster = 1;

  &RSAT::message::Info("Reading patterns from file $pattern_file") if ($verbose >= 4);

  ## single pattern specified on the command line
  if ($pattern_seq) {
    if ($pattern_id) {
      $pattern_id = $pattern_id;
    } else {
      $pattern_id = $pattern_seq;
    }
    push @patterns, new RSAT::pattern(id=>$pattern_id,
				      sequence=>$pattern_seq,
				      score=>$pattern_score,
				      cluster=>1
				     );
  } else {

    ## Read patterns from a file or from standard input
    my ($pattern_stream) = &OpenInputFile($pattern_file);
    my $l=0;
    while (my $line = <$pattern_stream>) {
      $l++;
      chomp($line);
      next if ($line =~ /^#/);
      next if ($line =~ /^seq/); ## Required to read pattern clusters exported by cluster_position_profiles.R
      next unless ($line =~ /\S/);

      if ($line =~ /^;/) {
	## For piping with oligo-analysis and dyad-analysis, identify
	## the column containing occ_sig, and use it as score column
	if (!($score_column) &&
	    (($line =~ /^;\s+(\d+)\s+occ_sig\s+/) || ## for oligo-analysis, dyad-analysis, orm.py
	     ($line =~ /^;\s+(\d+)\s+sig\s+/) || ## for position-analysis if chi2 sig has been computed
	     #	       ($line =~ /^;\s+(\d+)\s+chi2\s+/) || ## for position-analysis if chi2 sig has not been computed
	     ($line =~ /^;\s+Output score column\s+(\d+)/))
	   ) {
	  $score_column = $1;
	}
	next;
      }

      $line = &trim($line);	### remove leading and trailing spaces
      my @fields = split /\s+/, $line;
      next unless ($fields[0] =~ /\S/); ## Skip lines with empty pattern column
      $pattern_seq = $fields[0];

      ## Convert pattern generated by pattern assemby
      $pattern_seq =~ s/^\.+//;	      ## trim leading dots
      $pattern_seq =~ s/\.+$//;	      ## trim trailing dots
      $pattern_seq =~ s/\./n/g;	      ## convert inner dots to n
      if (($noid) || ($fields[1] !~ /\S/)) {
	$pattern_id = $pattern_seq;
      } else {
	$pattern_id = $fields[1];
      }

      ## Extract pattern score
      if ($score_column >= 1) {
	$pattern_score = $fields[$score_column - 1];
	$pattern_score =~ s/^\+//; ## remove trailing +
#	&RSAT::message::Debug("pattern score", $pattern_id, $pattern_score) if ($main::verbose >= 10);
	unless (&IsReal($pattern_score)) {
	  if (lc($pattern_score) eq "inf") {
	    unless ($args{inf_scores}) {
	      $pattern_score = 350; ## Arbitrary value for significance scores extending over the precision limit
	    }
	  } else {
	    $pattern_score = 1;
	  }
	}
      } else {
	$pattern_score = 1;	## default score
      }

      ## Extract pattern cluster
      if ($cluster_column >= 1) {
	$pattern_cluster = $fields[$cluster_column - 1] || "NA";
#	&RSAT::message::Debug("pattern cluster", $pattern_id, $pattern_cluster) if ($main::verbose >= 10);
      } else {
	$pattern_cluster = 1;	## default cluster
      }

      ## Expand pattern sequence (regexp spacers)
      if ($args{expand}) {
	$pattern_seq = &ExpandSeq($pattern_seq);
      }

      ## Instantiate the pattern object
      my $new_pattern = new RSAT::pattern(id=>$pattern_id,
					  description=>$line,
					  sequence=>$pattern_seq,
					  score=>$pattern_score,
					  cluster=>$pattern_cluster
					 );

      ## Add new pattern to pattern list
      push @patterns, $new_pattern;

      ## Debugging
      &RSAT::message::Debug ("&ReatPatterns()", "pattern",
			     $pattern_id,
			     $pattern_seq,
			     $pattern_score) if ($verbose >=5);
    }
    close $pattern_stream;
  }
  return @patterns;
}

################################################################
## The first time the routine is called with a given pattern the
## reverse complement is calculated and the result is cached in a hash
## table for further calls.
sub SmartRC {
    my $direct_seq = lc($_[0]);
    unless (defined($SmartRC{$direct_seq})) {
	$SmartRC{$direct_seq} = lc(&ReverseComplement($direct_seq));
    }
    return($SmartRC{$direct_seq});
}

################################################################
## Print pattern ID, depending on the strands
sub PatternID {
    my ($pattern_seq, $sum_rc) = @_;
    if ($sum_rc) {
	return join( "",  $pattern_seq, "|", lc(&SmartRC($pattern_seq)));
    } else {
	return $pattern_seq;
    }
}



1;

