#!/usr/bin/env perl
use CGI;

use LWP::Simple;
use JSON;

package main;
require RSAT::OrganismManager;
require RSAT::server;
require RSAT::email;
require RSAT::error;
require RSAT::Tree;


################################################################
## Load the default parameters for get-orthologs`
sub LoadGetOrthoComparaDefault {
    ## TO DO (JVH): ADAPT THIS FOR THE NON-PLANT SERVERS
  $default{organism} = "arabidopsis_thaliana";
  $default{queries} = '';
  $default{type} = "ortholog";
  $default{ident_target} = 70;
  $default{ident_query} = 70;
  $default{demo_descr} = "";

  ## Replace defaults by parameters from the CGI call, if defined
  foreach $key (keys %default) {
      if ($query->param($key)) {
	  $default{$key} = $query->param($key);
      }
  }
}


################################################################
## Load the default parameters for get-orthologs`
sub LoadGetOrthoDefault {
    #$default{organism} = "Escherichia_coli_GCF_000005845.2_ASM584v2";
    #$default{organism} = "Escherichia_coli_K_12_substr__MG1655_uid57779";
    #$default{taxon} = "Enterobacteriales";
  $default{queries} = '';
  $default{full} = '';
  $default{match_description} = '';
  $default{feattype} = "CDS";
  $default{ortho_lth_ali_len} = 50;
  $default{ortho_uth_e_value} = 1e-5;
  $default{ortho_uth_rank} = 1;
  $default{ortho_uth_s_rank} = 1;
  $default{return_ident} = "checked";
  $default{return_ali_len} = "checked";
  $default{return_mismat} = "";
  $default{return_gap_open} = "";
  $default{return_e_value} = "checked";
  $default{return_bit_sc} = "";
  $default{return_rank} = "checked";
  $default{return_s_rank} = "checked";
  $default{unique_taxon} = "species";
}

###############################################################
## Print the options for get-orthologs-compara:
## -ref_org, -i,
sub PrintOrthoComparaSelectionSection {

    # populate list of supported organisms
    my @supported_organisms_fullnames = ();
    open(GETORTHSCOMP,"$ENV{RSAT}/perl-scripts/get-orthologs-compara -supported_organisms |") ||
        warn "# cannot run get-orthologs-compara -supported_organisms\n";
    while(<GETORTHSCOMP>){
        next if(/Supported/);
        chomp;
        push(@supported_organisms_fullnames,$_); # if($org =~ /\.\d/);#release number;
    }
    close(GETORTHSCOMP);

    ## Choice of the organism
    print "<b>Reference </b>";
    ## print &OrganismPopUpCompara(@supported_organisms_fullnames);
    ## NOT YET TREATED: CHOOSE MULTIPLE ORGANISMS
    print &OrganismScrollingListCompara(@supported_organisms_fullnames), "\n";

    ################################################################
    ### gene queries
    print "<p><B><A class='iframe' HREF='help.get-orthologs-compara.html#genes'>Query genes</A></B>&nbsp;";
    print "<p>Paste query Ensembl gene IDs (one query per row)<br>\n";
    print $query->textarea(-name=>'queries',
			   -default=>$default{queries},
			   -rows=>3,
			   -columns=>40);

    ### option to upload a file with the gene list from the client machine
    print "<p><b>or</b> upload gene list from file<BR>\n";
    print $query->filefield(-name=>'uploaded_file',
			    -default=>'',
			    -size=>45,
			    -maxlength=>200);
    print "<p>\n";

}

################################################################
## Print the options for selecting ortholofs:
## - query organism
## - query genes
## - reference taxon
sub PrintOrthoSelectionSection {

  my %supported_genome_blast = ();
  my @supported_orthologs = ();
  my %supported_orthologs = ();

  ################################################################
  ## List of organisms for which ortholog search is supported.
  ##
  ## This is temporary, we need to find a way to provide orhtologs for
  ## all organisms.
  ## Read supported orthologs from file
#  my $fp_org_file = $ENV{RSAT}."/public_html/data/supported_blast_tables.tab";
#  &RSAT::message::Debug("supported BLAST tables", $fp_org_file) if ($main::verbose >= 5);
#  if (-e $fp_org_file) {
#    my ($fp_org) = &OpenInputFile($fp_org_file);
#    while (<$fp_org>) {
#      next unless (/\S/) ; # skip empty rows
#      next if (/^;/); # skip comment lines
#      next if (/^\#/); # Skip header line
#      
#      my @split_line = split(/\t/, $_);
#      my $org = $split_line[0];
#      my $taxa = $split_line[1];	  
#      
#      if ($org) {
#	
##	      if (defined($supported_organism{$org})) {## This control seems
##	      not to work, probably because the library is read before the
##	      list of supported organisms.
#		$supported_orthologs{$org} = 1;
#		$supported_genome_blast{$org}{$taxa} = 1;
##	      }
#      }
#    }
#    @supported_orthologs = sort keys %supported_orthologs;
#  } else {
#    &RSAT::error::FatalError("Missing file", $fp_org_file);
#  }
  

  ## Choice of the organism
  print "<b>Query </b>";

  #&OrganismPopUp(@supported_orthologs);
  &OrganismPopUp('supported' => 'orthologs');

  ################################################################
  ### gene queries
  print "<B><A class='iframe' HREF='help.retrieve-seq.html#genes'>Query genes</A></B>&nbsp;";
  print "<BR>\n";
  print $query->textarea(-name=>'queries', -id=>'queries',
			 -default=>$default{queries},
			 -rows=>3,
			 -columns=>40);

  ## Option to upload a file with the gene list from the client machine
  print "<BR>Upload gene list from file<BR>\n";
  print $query->filefield(-name=>'uploaded_file',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
  print "<p>\n";

  ## Taxon of interest
#  &TaxonPopUp("node");
  &TaxonPopUp("all");

  ## ALE: This is not working correctly and makes a conflict since this taxon frequencies have not been calculated, and the final html name does not match.
  ## Select a single organism per taxon
  # print "<br>";
  # print "<b><a class='iframe' href='help.footprint-discovery.html#unique_taxon'>Unique organism per</a>&nbsp;</b>\n";
  # print $query->popup_menu(-name=>'unique_taxon', -id=>'unique_taxon',
  # 			   -Values=>['species',
  # 				     'genus',
  # 				     'no filter'],
  # 			   -default=>$default{unique_taxon});

}


################################################################
## For debugging: if the echo level is >= 2, display the parameters
## transmitted to the CGI query.
## This method should be called from the cgi scripts
sub ListParameters {
  my($cgi_query) = $_[0];
  @param = $query->param;
  print "<h4>CGI query parameters</h4>";
  print "<ul><table>\n";
  foreach my $key (@param) {
    print "<tr>";
    print "<td valign=top><b>$key</b></td>";
    my $value = $query->param($key);
    $value =~ s/\n/<br>/g;
    print "<td valign=top>$value</td>";
    print "</tr>\n";
  }
  print "</table></ul>\n";
}


################################################################
## List the default parameter values for a CGI script
## This method should be called from the *_form.cgi scripts
sub ListDefaultParameters {
  @param = $query->param;
  print "<h4>Default parameter values</h4>";
  print "<ul><table>\n";
  foreach my $key (sort keys %main::default) {
    print "<tr>";
    print "<td valign=top><b>$key</b></td>";
    my $value = $default{$key};
    $value =~ s/\n/<br>/g;
    print "<td valign=top>$value</td>";
    print "</tr>\n";
  }
  print "</table></ul>\n";
}

################################################################
## returns all the fields of the %input hash
## TO CHECK: IS THIS METHOD STILL USED ? LOOKS LIKE AN OLD VERSION OF &LISTPARAMETERS()
sub Print_CGI_Input {
    print "<pre>";
    foreach $key (sort keys %input) {
	print "$key\t$input{$key}\n";
    }
    print "</pre>";

    print "Parameters: $parameters<P><P>\n";
}


sub display_bioschemas {
  my $form = $0;
  my $bioschemas_file = $form;
  $bioschemas_file =~ s/\.cgi/_bioschemas\.json/;
#  die $bioschemas_file;
  # $bioschemas_file = $ENV{RSAT}."/public_html/supported-organisms_bioschemas.json";
  if (-e $bioschemas_file) {
    print "\n\n";
    print '<script type="application/ld+json">', "\n";
    my $json = `cat $bioschemas_file`;
    $json =~ s/\$ENV\{rsat_www\}/$ENV{rsat_www}/;
    print $json, "\n";
    print '</script>', "\n\n";
  }
}

sub RSA_header_bootstrap {
    my $css_body_class = "form";
    my ($title) = shift;
    $title =~ s/\"//g;
    $title =~ s/\'//g;
    if (scalar @_ > 0) {
        $css_body_class = shift;
    }
    print $query->header();
    print sorttable_script();

    print $query->start_html(-title=>"RSAT : $title",
    -class => "$css_body_class",
    -author=>'Jacques.van-Helden\@univ-amu.fr',
    -script=>[
    { -type => 'text/javascript',
        -src      => 'js/jquery.js'
    },
    { -type => 'text/javascript',
        -src      => 'https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js'
    },
    { -type => 'text/javascript',
        -src      => 'js/RSAT_menu.js'
    },
    { -type => 'text/javascript',
        -src      => 'js/RSAT_tabs.js'
    }
   ],
    -style => { 	-src => ["css/bootstrap.min.css","css/bhoechie-tab.css","css/tabs.css","css/chosen.css","css/font-awesome.min.css","css/form.css"],
        -type => 'text/css',
        -media => 'screen,projection,print' });

print '<script>
$(function(){
if(typeof demo !== "undefined"){
txt = demo.value;
if(txt){
document.getElementById("demo_descr").innerHTML = txt;
}

}
});
</script>

<!-- for the bootstrap forms-->
<script>
$(document).ready(function() {
    $("div.bhoechie-tab-menu>div.list-group>a").click(function(e) {
        e.preventDefault();
        $(this).siblings("a.active").removeClass("active");
        $(this).addClass("active");
        var index = $(this).index();
        $("div.bhoechie-tab>div.bhoechie-tab-content").removeClass("active");
        $("div.bhoechie-tab>div.bhoechie-tab-content").eq(index).addClass("active");
    });
});
</script>

<!-- for the bootstrap tooltips-->
<script>
$(document).ready(function(){
    $(\'[data-toggle="tooltip"]\').tooltip();
    $(\'[rel="popover"]\').popover();
});
</script>

';

    system("php menu.php");
    print "<div class='container' id='page-content-wrapper'>";

    if(!($title =~ 'RSAT home') && !($title =~ "Publications")) {
        print "<span class='menu-toggle'><a href='#' id='menu-toggle'><i class='fa fa-bars fa-2x' style='color:green;'></i></a></span><!--h3 align='center'><a href='RSAT_home.cgi'>RSAT</a> - $title</h3-->";
    }


    &RSAT::server::DetectDeniedIP();
    &display_bioschemas()

}

## ##############################################################
## Start a new HTML page and write the header of a RSAT query form or result
## page usage &RSA_header($program_name)

sub RSA_header {
    my $css_body_class = "form";
    my ($title) = shift;
    $title =~ s/\"//g;
    $title =~ s/\'//g;
    if (scalar @_ > 0) {
        $css_body_class = shift;
    }
    print $query->header();
    print sorttable_script();

    print $query->start_html(-title=>"RSAT : $title",
    -class => "$css_body_class",
    -author=>'Jacques.van-Helden\@univ-amu.fr',
    -script=>[
    { -type => 'text/javascript',
        -src      => 'js/jquery.js'
    },
    { -type => 'text/javascript',
        -src      => 'js/RSAT_menu.js'
    },
    { -type => 'text/javascript',
        -src      => 'js/RSAT_tabs.js'
    }
   ],
    -style => { 	-src => ["css/main.css","css/tabs.css","css/chosen.css","css/font-awesome.min.css"],
        -type => 'text/css',
        -media => 'screen,projection,print' });
    
    if($css_body_class eq "results"){
        print "<style>#page-content-wrapper{
                    overflow: auto !important;
                    display: block;
                    height: 100%;
                }</style>";
    }

print '<script>
$(function(){
if(typeof demo !== "undefined"){
txt = demo.value;
if(txt){
document.getElementById("demo_descr").innerHTML = txt;
}

}
});
</script>';

system("php menu.php");

print "<div class='container' id='page-content-wrapper'>";

    if(!($title =~ 'RSAT home') && !($title =~ "Publications")) {
        print "<span class='menu-toggle'><a href='#' id='menu-toggle'><i class='fa fa-bars fa-2x' style='color:green;'></i></a></span><h3 align='center'><a href='RSAT_home.cgi'>RSAT</a> - $title</h3>";
    }


    &RSAT::server::DetectDeniedIP();
    &display_bioschemas()

}



################################################################
## Print the piece of form to choose between sending results by e-mail, store
## on the server, or display on the browser.
sub SelectOutput {
    my ($default_output, %args) = @_;

    ## Check and adapt default output if necessary
    if (($ENV{mail_supported} eq "no") && ($default_output eq "email")) {
	$default_output = "display";
    } elsif ($args{email_only}) {
	$default{output} = 'email';
    } elsif ($default_output eq "") {
	$default_output = "display";
    }

    ## Collect the possible output types to be displayed
    my @values = ();
    if ($args{email_only}) {
	push @values, 'email';
    } else {
	if ($default_output eq 'server') {
	    push @values, 'server';
	}
	push @values, ('display');
	push @values, ('email') unless ($ENV{mail_supported} eq "no");
    }

    ## Display the output choice
    print "<B>Output</B>&nbsp;";
    print $query->radio_group(-name=>'output', -id=>'output',
			      -values=>[@values],
			      -default=>$default_output);
    print "&nbsp;";
    print $query->textfield(-name=>'user_email', -id=>'user_email', class=>'form-control', -size=>30,
	) unless ($ENV{mail_supported} eq "no");
    print "<BR>\n";
}




#################################
## Input choice.
## Print a section enabling to enter some input in various ways:
## - copy/paste in a text area
## - file on the server, transferred from previous application
## - upload a local file from the client computer
## - URL of a file (will be downloaded)
sub MultiInputChoice {
  my ($in_title, $in_num, $in_type, $in_format) = @_;

  my $inputChoiceString = "<B>$in_title</B>";
  my $input_file = "";
  $in_type = $in_type || "input";
  $in_firmat = $in_format || "text";

  if ($input_file = $query->param("input_file")) {

    ## Input file is already on the server machine
    ## (piped from a previous script)
    $input_url = $input_file;
    $input_url =~ s|$ENV{RSAT}/public_html|$ENV{rsat_www}|;
    $inputChoiceString .=  "<a href=$input_url>";
    $inputChoiceString .=  " transferred from previous query<BR>\n";
    $inputChoiceString .=  "</a>";
    $input_format = $query->param(input_format);
    $inputChoiceString .=  "<INPUT type='hidden' NAME='input_format' VALUE='$input_format'>\n";
    $inputChoiceString .=  "<INPUT type='hidden' NAME='input_file' VALUE='$input_file'>\n";

  } else {

    ## Text area to copy-paste the input
    $inputChoiceString .=  "&nbsp;"x5;
    $inputChoiceString .=  "Paste your ".$in_type." (".$in_format." format)<BR>\n";
    $inputChoiceString .=  $query->textarea(-name=>'input'.$in_num, -id=>'input'.$in_num,
					    -default=>$default{"input".$in_num},
					    -rows=>4,
					    -columns=>55);
    $inputChoiceString .=  "<BR>\n";

    ## Option to upload the input file from the client machine
    $inputChoiceString .=  "Or select a file to upload (.gz compressed files supported) <BR>\n";
    $inputChoiceString .=  $query->filefield(-name=>'uploaded_file'.$in_num, -id=>'uploaded_file'.$in_num,
						-default=>'',
						-size=>45,
						-maxlength=>200);
    $inputChoiceString .=  "<BR>\n";

    ## Option to fetch input file from an URL
    $inputChoiceString .=  "&nbsp;"x3;
    $inputChoiceString .=  "URL of a ".$in_type." file available on a Web server.<br>\n";
    $inputChoiceString .=  $query->textfield(-name=>'input_url'.$in_num, -id=>'input_url'.$in_num,
						-default=>$default{'input_url'.$in_num},
						-size=>62);
    $inputChoiceString .= "<br>\n";


  }
  print($inputChoiceString);
}

########################
## MultiGetInputFile
sub MultiGetInputFile {
  my ($in_num, $input_file, $required_opt) = @_ ;

  ################################################################
  ## Upload input file from the client
  my $upload_file = $query->param('uploaded_file'.$in_num);
  if ($upload_file) {
    if ($upload_file =~ /\.gz$/) {
      $input_file .= ".gz";
    }
    $type = $query->uploadInfo($upload_file)->{'Content-Type'};
    open IN, ">$input_file" ||
      &cgiError("Cannot store input file in temp dir.");
    while (<$upload_file>) {
      print IN;
    }
    close IN;

    ### Fetch input from an URL
  } elsif ($query->param('input_url'.$in_num) =~ /\S/) {
    my $url = $query->param('input_url'.$in_num);
    &RSAT::message::Info("Fetching input file from URL ".$url) if ($ENV{rsat_echo} >= 0);
    my $in = "";
    if (open IN, ">$input_file") {
      $in = get($url);
      if ($in =~ /\S/) {
	print IN $in;
	close IN;
      } else {
	&RSAT::error::FatalError("No input could be downloaded from the URL ".$url);
      }
    }

    ## Check input file
    my $file_type = `file $input_file`;
    if ($file_type =~ "gzip") {
      &RSAT::message::TimeWarn("Uncompressing input file", $input_file);
      my $cmd = "mv ".$input_file." ".$input_file.".gz";
      $cmd .= " ; gunzip ".$input_file.".gz";
      &doit($cmd);
    }


    &RSAT::message::Debug("Input file=", &RSAT::util::hide_RSAT_path($input_file),
			  "<p>File type=", &RSAT::util::hide_RSAT_path($file_type),
	) if ($main::verbose >= 5);

#    my $in_kb = sprintf("%d", length($in)/1000);

  } elsif ($query->param('input_file')) {
    $input_file = $query->param('input_file');

    ### Read input from the textarea "input"
  } elsif ($query->param('input'.$in_num) =~ /\S/) {
    if (open IN, ">$input_file") {
      print IN $query->param('input'.$in_num);
      close IN;
    }


  } else {
    if ($required_opt) { ## only returns return if this is a required option
      &cgiError("The input box should not be empty.");
    } else {
      $input_file = '';
    }
  }


  ## Uncompress gzipped files, because some programs cannot uncompress on the flight
  if ($input_file =~ /.gz$/) {
    &doit("gunzip -f ".$input_file);
    $input_file =~ s/.gz$//;
  }

  ## input file will be deleted
  &DelayedRemoval($input_file);

  return($input_file);
}


################################################################
## Print a selection between different modes of sequence entry
## in a HTML form
## - sequences copy-pasted in a textarea
## - sequences uploaded from a file on the client side
## - sequences piped from a previous script, and stored on the server
##   (typically  in a temporary dir)
sub DisplaySequenceChoice {
    print &SequenceChoice();
}

sub SequenceChoice {
  my $sequenceChoiceString = "";
  $sequenceChoiceString .=  "<B>Sequence</B>";
  #$sequenceChoiceString .=  "<UL>\n";
  my $sequence_file = "";


  if ($sequence_file = $query->param("sequence_file")) {
    ## Sequence file is already on the server machine
    ## (piped from a previous script)
    $sequence_url = $sequence_file;
    $sequence_url =~ s|$ENV{RSAT}/public_html|$ENV{rsat_www}|;
    $sequenceChoiceString .=  "<a href=$sequence_url>";
    $sequenceChoiceString .=  " transferred from previous query<BR>\n";
    $sequenceChoiceString .=  "</a>";
    $sequence_format = $query->param(sequence_format);
    $sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_format' VALUE='$sequence_format'>\n";
    $sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_file' VALUE='$sequence_file'>\n";

  } else {
    #### sequence format (pop-up menu)
    $sequenceChoiceString .=  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
    $sequenceChoiceString .=  "<B><A class='iframe' HREF='help.formats.html'>Format</A></B>&nbsp;";
    $sequenceChoiceString .=  $query->popup_menu(-id=>'sequence_format',
						 -name=>'sequence_format',
						 -Values=>['fasta',
							   'ig',
							   'wconsensus',
							   'raw',
							   'ncbi',
							   "tab",
							   'multi'],
						 -default=>$sequence_format);
    
    ## Text area to copy-paste the sequence
    $sequenceChoiceString .=  "Paste your sequence in the box below<BR>\n";
    $sequenceChoiceString .=  $query->textarea(-id=>'sequence',
      -name=>'sequence',
					       -default=>$default{sequence},
					       -rows=>4,
					       -columns=>55);
    $sequenceChoiceString .=  "<BR>\n";

    ## Option to upload the sequence file from the client machine
    $sequenceChoiceString .=  "Or select a file to upload (.gz compressed files supported) <BR>\n";
    $sequenceChoiceString .=  $query->filefield(-name=>'uploaded_file',
						-default=>'',
						-size=>45,
						-maxlength=>200);
    $sequenceChoiceString .=  "<BR>\n";

  }

  ## Mask option
  $sequenceChoiceString .=  "<BR><B><A class='iframe' HREF='help.formats.html'>Mask</A></B>&nbsp;";
  $sequenceChoiceString .=  $query->popup_menu(-id=>'mask',
					       -name=>'mask',
					       -Values=>['none',
							 'upper',
							 'lower',
							 'non-dna'],
					       -default=>"non-dna");
  $sequenceChoiceString .=  "<BR>\n";

  #$sequenceChoiceString .=  "</UL>\n";
  return($sequenceChoiceString);
}



#################################
## Multiple Sequence choice
sub MultiSequenceChoice {
  my $seq_title = shift(@_);
  my $seq_num = shift(@_);
  my $sequenceChoiceString = "";
  $sequenceChoiceString .=  "<B>$seq_title</B>";
  #$sequenceChoiceString .=  "<UL>\n";
  my $sequence_file = "";

  if (($sequence_file = $query->param("sequence_file".$seq_num)) ||
      ($sequence_file = $query->param("sequence_file"))) {

    ## Sequence file is already on the server machine
    ## (piped from a previous script)
    $sequence_url = $sequence_file;
    $sequence_url =~ s|$ENV{RSAT}/public_html|$ENV{rsat_www}|;
    $sequenceChoiceString .=  "<a href=$sequence_url>";
    $sequenceChoiceString .=  " transferred from previous query<BR>\n";
    $sequenceChoiceString .=  "</a>";
    $sequence_format = $query->param(sequence_format);
    $sequenceChoiceString .=  "<INPUT type='hidden' id='sequence_format' NAME='sequence_format' VALUE='$sequence_format'>\n";
    $sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_file' VALUE='$sequence_file'>\n";

  } else {

#      &RSAT::message::Debug("default sequence",$default{sequence});
#      &RSAT::message::Debug("default sequence_url",$default{sequence_url});

    ## text area to copy-paste the sequence
    $sequenceChoiceString .=  "&nbsp;"x5;
    $sequenceChoiceString .=  "Paste your sequence (fasta format)<BR>\n";
    $sequenceChoiceString .=  $query->textarea(-name=>'sequence'.$seq_num, -id=>'sequence'.$seq_num,
					       -default=>$default{"sequence".$seq_num},
					       -rows=>4,
					       -columns=>55);
    $sequenceChoiceString .=  "<BR>\n";

    ## Option to upload the sequence file from the client machine
    $sequenceChoiceString .=  "Or select a file to upload (.gz compressed files supported) <BR>\n";
    $sequenceChoiceString .=  $query->filefield(-name=>'uploaded_file'.$seq_num,
						-default=>'',
						-size=>45,
						-maxlength=>200);
    $sequenceChoiceString .=  "<BR>\n";

    ## Option to fetch sequence file from an URL
    $sequenceChoiceString .=  "&nbsp;"x3;
    $sequenceChoiceString .=  "URL of a sequence file available on a Web server (e.g. Galaxy).<BR>\n";
    $sequenceChoiceString .=  $query->textfield(-name=>'sequence_url'.$seq_num,-id=>'sequence_url'.$seq_num,
						-default=>$default{'sequence_url'.$seq_num},
						-size=>62);
    $sequenceChoiceString .= "<br>\n";

    #### Mask option
    $sequenceChoiceString .=  "<BR><B><A class='iframe' HREF='help.formats.html'>Mask</A></B>&nbsp;";
    $sequenceChoiceString .=  $query->popup_menu(-name=>'mask'.$seq_num,
						 -Values=>['none',
							   'upper',
							   'lower',
							   'non-dna'],
						 -default=>"none");
    $sequenceChoiceString .=  "<BR>\n";

  }
  print($sequenceChoiceString);
}


################################################################
## Print the commande on the Web interface (for debugging)
sub ReportWebCommand {
  my ($command, $err_file) = @_;
  print "<b>Server command</b><pre>", &RSAT::util::hide_RSAT_path($command), "\n</pre>\n";
  if ($err_file) {
      print "<pre><b>Error log</b>: ", &RSAT::util::hide_RSAT_path($err_file), "</pre>\n";
  }
}


################################################################
## Treat input sequence for the RSAT web server
## The seqence can be specified in 3 ways :
## - as a file to upload from the client to the server $query->param('uploaded_file')
## - as a text in the textarea $query->param('sequence')
## - as a sequence file already on the server $query->param('sequence_file')
##
## Usage:
##    ($sequence_file,$sequence_format) = &GetSequenceFile();
##    ($sequence_file,$sequence_format) = &GetSequenceFile($required_format,
##                                                         add_rc=>1,
##                                                         skip_short=>30);
sub GetSequenceFile {
  my ($required_format, %args) = @_;
  my $add_rc = $args{add_rc} || 0;
  my $no_format = $args{no_format} || 0;
  my $skip_short = $args{skip_short} || 0;
  my $sequence_file = "";

  ### sequence file format
  my $sequence_format = lc($query->param("sequence_format"));
  unless ($accepted_input_seq{$sequence_format}) {
    &cgiError("Invalid sequence format : '$sequence_format'.");
  }

  unless ($sequence_file = $query->param('sequence_file')) {
    ### sequence file already on the server side
    ### create a new temporary sequence file
    $sequence_file = &RSAT::util::make_temp_file("","tmp_sequence", 1);

    ### upload sequence file from the client side
    my $upload_file = $query->param('uploaded_file');
    if ($upload_file) {
      &RSAT::message::TimeWarn("Uploading file", $upload_file) if ($ENV{rsat_echo} >= 2);
      if ($upload_file =~ /\.gz$/) {
	$sequence_file .= ".gz";
      }
      $type = $query->uploadInfo($upload_file)->{'Content-Type'};
      open SEQ, ">$sequence_file" ||
	&cgiError("Cannot store sequence file in temp dir.");
      my $data_size = 0;
      while (<$upload_file>) {
	  $data_size += length($_);
	print SEQ;
      }
      close SEQ;
      &RSAT::message::Info("Uploaded file", $upload_file, $data_size." bytes") if ($ENV{rsat_echo} >= 1);
      if ($data_size == 0) {
	  &RSAT::error::FatalError("Uploaded file is empty. Please check the size of your local file (".$upload_file."). If this file is not empty, please contact the RSAT administrator (".$ENV{rsat_server_admin}.").");
      }

      ### read sequence from the textarea "sequence"
    } elsif ($query->param('sequence') =~ /\S/) {
      if (open SEQ, ">$sequence_file") {
	print SEQ $query->param('sequence');
	close SEQ;
      }
    } else {
      &cgiError("The sequence box should not be empty.");
    }

    #### sequence file will be deleted
    &DelayedRemoval($sequence_file);
  }
  $sequence_file =~ s/\s+$//g;

  ## Mask option
  my $mask = "";
  if ($query->param('mask')) {
    unless ($query->param('mask') eq "none") {
      $mask = $query->param('mask');
      &CheckMask($mask);
    }
  }

  #### convert-seq
  if (($add_rc) ||
      ($mask) ||
      ($skip_short) ||
      ((defined($required_format)) && (lc($sequence_format) ne lc($required_format)))
     ) {

    ## Check required format
    unless ($required_format) {
      $required_format = $sequence_format;
    }
    unless ($accepted_output_seq{$required_format}) {
      &cgiError("Invalid sequence format : ${required_format}.");
    }
    my $converted_seq_file = $sequence_file.".".$required_format;
    my $convert_seq_command = $SCRIPTS."/convert-seq ";
    $convert_seq_command .= " -i ".$sequence_file;
    $convert_seq_command .= " -from  $sequence_format -to $required_format ";

    my $sequence_type = lc($query->param('sequence_type'));

    if ($sequence_type eq "dna") {
      ## Add reverse complement
      if ($add_rc) {
	$convert_seq_command .= " -addrc ";
      }
    }

    ## Mask
    if ($mask) {
      if (($sequence_type eq "protein") && ($mask eq "non-dna")) {
	&RSAT::message::Warning("non-dna masking is not compatible with sequence type", $sequence_type);
      } else {
	$convert_seq_command .= " -mask ".$mask;
      }
    }

    ## Skip short sequences
    if ($skip_short) {
      $convert_seq_command .= " -skip_short ".$skip_short;
    }

    $convert_seq_command .= " -o ".$converted_seq_file;

    ## Execute the sequence conversion
    system($convert_seq_command);

    print "<pre>", &RSAT::util::hide_RSAT_path($convert_seq_command), "</pre>\n" if ($ENV{rsat_echo} >= 1);
    &DelayedRemoval($converted_seq_file);
    $sequence_file = $converted_seq_file;
    $sequence_format = $required_format;
  }

  return($sequence_file, $sequence_format);
}

########################
## MultiGetSequenceFile
sub MultiGetSequenceFile {
  my ($seq_num, $sequence_file, $required_opt) = @_ ;


  ### sequence file format
  my $sequence_format = "fasta";
  #    my $sequence_format = lc($query->param("sequence_format".$seq_num));
#  unless ($accepted_input_seq{$sequence_format}) {
#    &cgiError("Invalid sequence format : '$sequence_format'.");
#  }

  ################################################################
  ## Upload sequence file from the client
  my $upload_file = $query->param('uploaded_file'.$seq_num);
  if ($upload_file) {
    if ($upload_file =~ /\.gz$/) {
      $sequence_file .= ".gz";
    }
    $type = $query->uploadInfo($upload_file)->{'Content-Type'};
    open SEQ, ">$sequence_file" ||
      &cgiError("Cannot store sequence file in temp dir.");
    while (<$upload_file>) {
      print SEQ;
    }
    close SEQ;

    ### Fetch sequence from an URL
  } elsif ($query->param('sequence_url'.$seq_num) =~ /\S/) {
    my $url = $query->param('sequence_url'.$seq_num);
    &RSAT::message::Info("Fetching sequences from URL ".$url) if ($ENV{rsat_echo} >= 1);
    my $seq = "";
    if (open SEQ, ">$sequence_file") {
      $seq = get($url);
      if ($seq =~ /\S/) {
	print SEQ $seq;
	close SEQ;
      } else {
	&RSAT::error::FatalError("No sequence could be downloaded from the URL ".$url);
      }
    }

    ## Check sequence file
    my $file_type = `file $sequence_file`;
    if ($file_type =~ "gzip") {
      &RSAT::message::TimeWarn("Uncompressing sequence file", $sequence_file);
      my $cmd = "mv ".$sequence_file." ".$sequence_file.".gz";
      $cmd .= " ; gunzip ".$sequence_file.".gz";
      &doit($cmd);
    }


    &RSAT::message::Debug("Sequence file=", &RSAT::util::hide_RSAT_path($sequence_file),
			  "<p>File type=", &RSAT::util::hide_RSAT_path($file_type),
	) if ($main::verbose >= 5);

#    my $seq_kb = sprintf("%d", length($seq)/1000);

    ### Read sequence from the textarea "sequence"
  } elsif ($query->param('sequence'.$seq_num) =~ /\S/) {
    if (open SEQ, ">$sequence_file") {
      print SEQ $query->param('sequence'.$seq_num);
      close SEQ;
    }


  } else {
    if ($required_opt) { ## only returns return if this is a required option
      &cgiError("The sequence box $seq_num should not be empty.");
    } else {
      $sequence_file = '';
      $sequence_format = '';
    }
  }

  ## Mask option
  my $mask = "";
  if ($query->param('mask'.$seq_num)) {
    unless ($query->param('mask'.$seq_num) eq "none") {
      $mask = $query->param('mask'.$seq_num);
      &CheckMask($mask);
      my $converted_seq_file = $sequence_file.".masked";
      my $convert_seq_command = $SCRIPTS."/convert-seq ";
      $convert_seq_command .= " -i ".$sequence_file;
      $convert_seq_command .= " -from  $sequence_format -to fasta ";
##    $convert_seq_command .= " -from  fasta -to fasta ";
      $convert_seq_command .= " -mask ".$mask;
      $convert_seq_command .= " -o ".$converted_seq_file;
      ## Execute the sequence conversion
      system($convert_seq_command);

      print "<pre>", &RSAT::util::hide_RSAT_path($convert_seq_command), "</pre>\n" if ($ENV{rsat_echo} >= 0);
      &DelayedRemoval($converted_seq_file);
      $sequence_file = $converted_seq_file;
    }
  }



  #### sequence file will be deleted
  &DelayedRemoval($sequence_file);

  return($sequence_file, $sequence_format);
}

#### warn the users to wait for complete result before clicking on piping buttons
sub PipingWarning {
    my $message = "One or several button(s) will appear at the bottom of this page, ";
    $message .= "allowing you to send the result as input for a subsequent query.";
    &cgiMessage($message, "Information");
}


################################################################
## Display a pop-up menu with a selection of organism on the
## basis of the server-specific list of supported organisms.
## JvH: I should check if thi is still required, or replace it by OrganismPopupSelectable
sub OrganismPopUp {
    print &OrganismPopUpString(@_);
}


################################################################
## Generate a *dynamic* pop-up menu with a selection of organism on the
## basis of the server-specific list of supported organisms.
sub OrganismPopUpSelectable {
  my $popup = "";

  ## Include a javascript to enable dynamic selection of subsets of matching organisms
  $popup .=  "<script type='text/javascript' src='".$ENV{RSAT}."/perl-scripts/lib/js/DataTables-1.10.4/media/js/jquery.js'>\n";
  $popup .=  `cat $ENV{RSAT}/perl-scripts/lib/js/popup-sub-select.js`;
  $popup =~ s/ui.combobox/organism/g;
  $popup .=  $script;
  $popup .=  "</script>\n";

  ## Embed the pop-up menu in a table
  $popup .=  "<table border='0' width='100%' cellspacing='0' cellpadding='2'>\n";
  $popup .=  "<tr>\n";
  $popup .=  "<td style='vertical-align:middle; text-align:left; width: 45%;'>\n";
  $popup .=  "<input type='text' id='theVisibleElement' value=''/>\n";
  $popup .=  &OrganismPopUpString(@_);
  $popup .=  "</td>\n";
  $popup .=  "</tr>\n";
  $popup .=  "</table>\n";
#  die "$popup";
  return $popup;
}


################################################################
## Generate a scrolling list allowing users to select multiple
## organisms for get-orthologs-compara.
sub OrganismScrollingListCompara {
    my (@selected_organisms) = @_;
    if (scalar(@selected_organisms) == 0) {
        @selected_organisms =
            &RSAT::OrganismManager::get_supported_organisms_web();
    }

    $organismList =  "<B>Organism</B>&nbsp;";
    $organismList .=
	$query->scrolling_list(-name=>'organism',
			       -values=>\@selected_organisms,
#			 -default=>['eenie','moe'],
			       -size=>10,
			       -multiple=>'true',
			       -labels=>\%labels,
			       -attributes=>\%attributes);
    return($organismList);
}

################################################################
## Generate pop-up menu to be displayed for organism selection in
## Compara.
sub OrganismPopUpCompara{
    my (@selected_organisms) = @_;
    if (scalar(@selected_organisms) == 0) {
        @selected_organisms =
            &RSAT::OrganismManager::get_supported_organisms_web();
    }



    my $organismPopup = "";
    $organismPopup .=  "<B>Organism</B>&nbsp;";
    print '<script type="text/javascript"> ' ;
    print `cat $ENV{RSAT}/perl-scripts/lib/js/DataTables-1.10.4/media/js/jquery.js`;
    print ' </script>';
    print '<script type="text/javascript"> ' ;
    print `cat $ENV{RSAT}/perl-scripts/lib/js/chosen/chosen.jquery.min.js`;
    print ' </script>';
    print '<script type="text/javascript">
     jQuery(document).ready(function(){
     $(".chosen-select").chosen();
     $(".chosen-container").css({"font-size": "11px"});
    });

    </script>';

    $organismPopup .=  "<select id='organism' name='organism' class='chosen-select' tabindex='2'>\n";
    foreach my $org (@selected_organisms) {
      my $name = $org;
      $name =~ s/\_/ /g;
      if ((lc($org) eq lc($default{organism})) ||
      (lc($name) eq lc($default{organism}))) {
        $organismPopup .=  "<option selected VALUE='$org'>$name\n";
      } else {
        $organismPopup .=  "<option value='$org'>$name\n";
      }
    }

    $organismPopup .=  "</select>";
    $organismPopup .= " <i>not seeing your favorite organism in the list? Contact us to have it installed </i>";
    $organismPopup .=  "<br>\n";
    return($organismPopup);
}


###########################
### Generate the content of the pop-up menu to be displayed for organism selection
### Options: bg_org => 1: if this pop-up is displayed for the background model (ex. in matrix-distrib, matrix-quality, or random-seq...)
#           supported => orthologs : if this pop-up is displayed for the orthologs organisms (ex. in get-orthologs)
#           supported => infer: if this pop-up is displayed for the relevant organisms for operon inference (ex. infer-operons)
sub OrganismPopUpString{
    my (%args) = @_;
   
    my $supported = $args{'supported'};
    my $supported_param = "?get=json";
    if($supported ne ""){
        $supported_param .= "&supported=$supported";
    }

    &check_prokaryote_server();

    my $bg_org = $args{'bg_org'};
    my $popupid = ($bg_org == 1) ? "organism_bg" : "organism";
    my $popupid_name = ($bg_org == 1) ? "organism_bg_name" : "organism_name";
    my $tip = ($bg_org == 1) ? "tip_bg" : "tip";
    
    my $organismPopup = "<div class='ui-widget' style='display:inline'>";
    $organismPopup .=  "<B>Organism</B>&nbsp;";
    
    if($default{organism} ne ""){
        $org_name = $default{organism};
        $org_name =~ s/_/\ /g;
        $organismPopup .= "<input id=$popupid_name name=$popupid_name autofocus='autofocus' value='$org_name' size='35' class='form-control'> <input id=$popupid name=$popupid value='$default{organism}' type='hidden'>";
    }else{
        $organismPopup .= "<input id=$popupid_name name=$popupid_name autofocus='autofocus' placeholder='Enter the name of your organism...' size='35' class='form-control'><input id=$popupid name=$popupid type='hidden'>";
    }
    $organismPopup .= "</div>";
    print "<script src='$ENV{rsat_www}/js/autocomplete/js/jquery-ui.min.js'></script>";
    print '<script type="text/javascript">
    jQuery(document).ready(function(){
        $("#' . $popupid_name . '").keypress(function(event){
            if(event.keyCode == 13){
                event.preventDefault();
            }
            $("#' . $popupid . '").val("");
        });
        $("#' . $popupid_name . '").bind("paste", function(e){
            $("#' . $popupid . '").val("");
        });
        
        $("#'.$popupid_name.'").focusout(function(){
            if(($("#'.$popupid. '").val() == "") && ($("#' . $popupid_name . '").val() != "")){
                $("#'.$popupid. '").val($("#' . $popupid_name . '").val());
            }
            if($("#' . $popupid_name . '").val() == ""){
                $("#'.$popupid. '").val("");
            }
        });
        
        //$("#' . $popupid_name . '").focusout(function(){
        //    if($("#' . $popupid . '").val() == ""){
        //        $("#' . $popupid_name . '").val("");
        //    }
        //});
        
        $("#' . $popupid_name . '").autocomplete({

                minLength: 2,
                source: "getOrganisms.cgi'. $supported_param .'",
                focus: function(event, ui){
                    $("#' . $popupid_name . '").val(ui.item.label);
                    return false;
                },
                    select: function(event, ui){
                        $("#' . $popupid . '").val(ui.item.value);
                        return false;
                    }
                }).autocomplete( "instance" )._renderItem = function(ul, item){
                    if(item.label != "null"){
                        var query = $("#' . $popupid_name . '").val().trim();
                        var terms = query.split(" ");
                        function replacer(match, ...ps){
                            var res = "";
                            var str = ps[ps.length - 1];
                            for(i = 0; i < ps.length - 3; i++){
                                ind = str.indexOf(ps[i]) + ps[i].length;
                                ind1 = str.indexOf(ps[i+1]);
                                res += "<font color=\"blue\">" + ps[i] + "</font>" + str.substring(ind, ind1);

                            }
                            ind = str.indexOf(ps[ps.length - 3]) + ps[ps.length-3].length;
                            res += "<font color=\"blue\">" + ps[ps.length - 3] + "</font>" + str.substring(ind);
                            return res;
                        }
                        var re = "";
                        for(var i = 0; i < terms.length; i++){
                            re += "(" + terms[i] + ").*";
                        }
                        var reg = new RegExp(re , "i", "m");
                        var t = item.label.replace(reg, replacer);

                        document.getElementById("' . $tip . '").style.display = "none";
                        return $( "<li>" ).append("<div>" + t + "</div>").appendTo( ul );
                    }else{
                        $("#' . $tip . '").html("<span style=\"color:orange\">Your search has no result</span>");
                        document.getElementById("'. $tip .'").style.display = "inline";
                        return false;
                    }
                };
            
    });
    </script>';
    if($args{supported}){
        $list = $args{supported};
        if($args{supported} eq "infer"){
            $list = "operon inference organisms";
        }elsif($args{supported} eq "variations"){
            $list = " organisms with variations";
        }
        $organismPopup .=  "<a href='getOrganisms.cgi?get=display&supported=$args{supported}' target='_blank'>  [List of $list]</a>";
    }
    
    else{
        $organismPopup .=  "<a href='supported-organisms.cgi' target='_blank'>  [List of organisms]</a>";
    }
    $organismPopup .= " <div id='$tip' style='display:none'></div> <i>not seeing your favorite organism in the list ? Contact us to have it installed </i><br/>";

    return $organismPopup;
}

################################################################
## Check if organism is supported
sub CheckOrganismAvail{
    my $org_check = shift;
    my $org_list = `$SCRIPTS/supported-organisms`;
    my @supported_orgs = split(/\n/, $org_list);
    foreach my $org (@supported_orgs){
        my $name = ucfirst($org);
        $name =~ s/_/ /;
        if((lc($org_check) eq lc($org)) || (lc($org_check) eq lc($name))){
            return $org;
        }
    }
    return "";
}

sub CheckTaxonAvail{
    my $taxon_check = shift;
    my @taxons = &get_taxons_web("all");
    foreach my $taxon (@taxons){
        if(lc($taxon) eq lc($taxon_check)){
            return $taxon;
        }
    }
    return "";
}
################################################################
## Display a pop-up menu with the list of organisms supported at
## Ensembl.
sub OrganismPopUpEnsembl {
    my (@selected_organisms) = @_;
    if (scalar(@selected_organisms) <= 0) {
      my $org_list = `$SCRIPTS/supported-organisms-ensembl`;
      @selected_organisms = split(/\n/,$org_list);
    }
    my $organismPopup = "";
    $organismPopup .=  "<B>Organism</B>&nbsp;";
    $organismPopup .=  "<SELECT id='organism_ens' NAME='organism_ens'>\n";
    foreach my $org (@selected_organisms) {
    $name = ucfirst($org);
    $name =~ s/_/ /;
	if ((lc($org) eq lc($default{organism_ens})) ||
        (lc($name) eq lc($default{organism_ens}))) {
		$org = lc($org);
	    $organismPopup .=  "<OPTION SELECTED VALUE='$org'>$name\n";
	}elsif (lc($org) =~ /^;/) {
	    $info_ensembl .=  $org;
	    $info_ensembl =~ s/;//;
	} else {
		$org = lc($org);
	    $organismPopup .=  "<OPTION VALUE='$org'>$name\n";
	}
    }
    $organismPopup .=  "</SELECT>";
    $organismPopup .=  $info_ensembl;
    $organismPopup .=  "<BR>\n";
    return $organismPopup;
}


################################################################
## Display a pop-up menu with the supported taxonomy on the basis of
## the server-specific table of supported organisms
sub TaxonPopUp {
    print &TaxonPopUpString(@_);
}

sub TaxonPopUpStringIndented {
    require RSAT::Tree;
    my $tree = new RSAT::Tree();
    $tree->LoadSupportedTaxonomy(undef, \%supported_organism, 1);
#    $tree->LoadSupportedTaxonomy(1);
    my @supported_taxons = $tree->node_names();
    my $indent_char = ":-";

    my %indented_taxa = ($tree->as_indented_hash($indent_char,"Bacteria"),
			 $tree->as_indented_hash($indent_char,"Fungi"));
    my $taxonomyPopup = "";
    $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
    $taxonomyPopup .=  "<SELECT NAME='taxon'>\n";
    foreach my $taxon (@supported_taxons) {
      if ($indented_taxa{$taxon}){
	$name = $indented_taxa{$taxon};
	if ((lc($taxon) eq lc($main::default{taxon})) ||
	    (lc($name) eq lc($main::default{taxon}))) {
	    $taxonomyPopup .=  "<OPTION SELECTED VALUE='$taxon'>$name\n";
	  } else {
	    $taxonomyPopup .=  "<OPTION VALUE='$taxon'>$name\n";
	  }
      }
    }
    $taxonomyPopup .=  "</SELECT>";
    $taxonomyPopup .=  "<BR>\n";
    return $taxonomyPopup;
}

##### Get list of supported taxons
sub get_taxons_web{
    my ($node_type) =  @_;
    $node_type = "node" unless ($node_type);
    require RSAT::Tree;
    my $tree = new RSAT::Tree();
    $tree->LoadSupportedTaxonomy(undef, \%supported_organism, 1);
    
    my @taxa = $tree->get_node_descendents_names("Bacteria",undef,$node_type);
    if (scalar(@taxa) == 0) {
        return ("");
        #    return ("No available taxonomic information.");
    }
    push @taxa, $tree->get_node_descendents_names("Fungi",undef,$node_type);
    @taxa = sort @taxa;
    return @taxa;
}
################################################################
## Generate a string with alphabetical
sub TaxonPopUpString {
  my ($node_type) =  @_;
  $node_type = "node" unless ($node_type);
  
  my $taxonomyPopup = "";
  if ($node_type eq "all") {
    $taxonomyPopup .=  "<B>Taxon/Organism</B>&nbsp;";
  } else {
    $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
  }
  ## NOT SUPPORTED YET: TO BE ADDED TO get-orghologs, footprint-discovery, footprint-scan
  # $taxonomyPopup .=  "&nbsp;"x5;
  # $taxonomyPopup .=  "<B>Taxonomic depth</B>&nbsp;";
  # $taxonomyPopup .= $query->popup_menu(-name=>'depth',
  # 				       -Values=>[0,1,2,3,4,5],
  # 				       -default=>$default{depth}||4);

   $taxonomyPopup .= "<input id='taxon_name' name='taxon_name' autofocus='autofocus' placeholder='Enter the name of your taxon...' size='35'><input id='taxon' name='taxon' type='hidden'>";
    print "<script src='$ENV{rsat_www}/js/autocomplete/js/jquery-ui.min.js'></script>";
    print '<script type="text/javascript">
    jQuery(document).ready(function(){
        $("#taxon_name").keypress(function(event){
            if(event.keyCode == 13){
                event.preventDefault();
            }
            $("#taxon").val("");
        });
        $("#taxon_name").bind("paste", function(e){
            $("#taxon").val("");
        });
        
        $("#taxon_name").focusout(function(){
            if(($("#taxon").val() == "") && ($("#taxon_name").val() != "")){
                $("#taxon").val($("#taxon_name").val());
            }
            if($("#taxon_name").val() == ""){
                $("#taxon").val("");
            }
        });
        //$("#taxon_name").focusout(function(){
        //    if($("#taxon").val() == ""){
        //        $("#taxon_name").val("");
        //    }
        //});
        
        $("#taxon_name").autocomplete({
        minLength: 2,
        source: "getOrganisms.cgi?get=json&taxon=yes&nodetype='.$node_type.'",
        focus: function(event, ui){
            $("#taxon_name").val(ui.item.label);
            return false;
        },
            select: function(event, ui){
                $("#taxon").val(ui.item.value);
                return false;
            }
        }).autocomplete( "instance" )._renderItem = function(ul, item){
            if(item.label != "null"){
                var query = $("#taxon_name").val().trim();
                var terms = query.split(" ");
                function replacer(match, ...ps){
                    var res = "";
                    var str = ps[ps.length - 1];
                    for(i = 0; i < ps.length - 3; i++){
                        ind = str.indexOf(ps[i]) + ps[i].length;
                        ind1 = str.indexOf(ps[i+1]);
                        res += "<font color=\"blue\">" + ps[i] + "</font>" + str.substring(ind, ind1);
                        
                    }
                    ind = str.indexOf(ps[ps.length - 3]) + ps[ps.length-3].length;
                    res += "<font color=\"blue\">" + ps[ps.length - 3] + "</font>" + str.substring(ind);
                    return res;
                }
                var re = "";
                for(var i = 0; i < terms.length; i++){
                    re += "(" + terms[i] + ").*";
                }
                var reg = new RegExp(re , "i", "m");
                var t = item.label.replace(reg, replacer);
                
                document.getElementById("tip-taxon").style.display = "none";
                return $( "<li>" ).append("<div>" + t + "</div>").appendTo( ul );
            }else{
                $("#tip-taxon").html("<span style=\"color:orange\">Your search has no result</span>");
                document.getElementById("tip-taxon").style.display = "inline";
                return false;
            }
        };
        
        $("#taxon_name").attr("autocomplete", "on");
        
    });
    </script>';
    $taxonomyPopup .=  "<a href='supported-taxonomy.cgi' target='_blank'>  [List of taxonomy]</a>";
    $taxonomyPopup .= " <div id='tip-taxon' style='display:none'></div>";
    return $taxonomyPopup;
}

sub TaxonPopUpString_old {
    my ($node_type) =  @_;
    $node_type = "node" unless ($node_type);
    require RSAT::Tree;
    my $tree = new RSAT::Tree();
    $tree->LoadSupportedTaxonomy(undef, \%supported_organism, 1);
    
    my @taxa = $tree->get_node_descendents_names("Bacteria",undef,$node_type);
    
    if (scalar(@taxa) == 0) {
        return ("");
        #    return ("No available taxonomic information.");
    }
    push @taxa, $tree->get_node_descendents_names("Fungi",undef,$node_type);
    @taxa = sort @taxa;
    
    my $taxonomyPopup = "";
    if ($node_type eq "all") {
        $taxonomyPopup .=  "<B>Taxon/Organism</B>&nbsp;";
    } else {
        $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
    }
    $taxonomyPopup .=  "<select name='taxon' id='taxon'>\n";
    foreach my $taxon (@taxa) {
        my $name = $taxon;
        $label =~ s/_/ /g;
        if ((lc($taxon) eq lc($main::default{taxon})) ||
        (lc($name) eq lc($main::default{taxon}))) {
            $taxonomyPopup .=  "<option selected value='$taxon'>$name\n";
        } else {
            $taxonomyPopup .=  "<option value='$taxon'>$name\n";
        }
    }
    $taxonomyPopup .=  "</select>";
    
    ## NOT SUPPORTED YET: TO BE ADDED TO get-orghologs, footprint-discovery, footprint-scan
    # $taxonomyPopup .=  "&nbsp;"x5;
    # $taxonomyPopup .=  "<B>Taxonomic depth</B>&nbsp;";
    # $taxonomyPopup .= $query->popup_menu(-name=>'depth',
    # 				       -Values=>[0,1,2,3,4,5],
    # 				       -default=>$default{depth}||4);
    
    $taxonomyPopup .=  "<BR>\n";
    return $taxonomyPopup;
}




################################################################
#Sequence boxes for matrix-quality

sub SeqBoxMQ {
  my $seq_num= shift(@_);
 # text area to enter the sequence
 # print "<h2>Dataset ".$seq_num."</h2>";
  print "<table ><tr><td>";
 &MultiSequenceChoice("Dataset ".$seq_num, $seq_num);
  print "</td>";

  if ($main::quality==1){
      print "<td>";
      print "<br>";

      print "<b><a class='iframe' href='help.convert-matrix.html#output_format'>&nbsp;&nbsp;&nbsp;&nbsp;Number of matrix permutations</A></B>&nbsp;";
      print $query->popup_menu(-name=>'permutation'.$seq_num, 
			       -id=>'permutation'.$seq_num,
			       -Values=>[0..5],
			       -default=>$default{perm});
      print "&nbsp;"x2,  $query->checkbox(-name=>'sep_perm'.$seq_num,
					  -id=>'sep_perm'.$seq_num,
					  -checked=>$default{sep_perm1},
					  -label=>''), "&nbsp;separate permutations" ;
      print "<br>\n";
      print"</td>";
  }

  print "<td>";
  print "<BR>\n";
  print "<B><A class='iframe' HREF='help.convert-seq.html#permutations'>&nbsp;&nbsp;&nbsp;&nbsp;Tag for this data set</A></b>\n";
  print $query->textfield(-name=>'tag'.$seq_num, -id=>'tag'.$seq_num,
			  -default=>$default{'tag'.$seq_num},
			  -size=>15);
  if ($main::quality == 1){
      print "<p></p>";

      print $query->checkbox(-name=>'nwd', -id=>'nwd',
			     -checked=>$default{nwd},
			     -label=>'');
      print "&nbsp;Calculate NWD";
      #print ("<INPUT TYPE='radio' NAME='nwd' VALUE='nwd' $checked{'nwd'}>","Calculate NWD");
  }
      print"</td>";
      print "</tr></table>";

}


################################################################
## Display the options for input matrices
##
## Arguments can be entered to modify the form by skipping some
## options.
##
## Usage: &GetMatrix(%args);
##
## Supported arguments:
##  no_pseudo=>1   do not display the pseudo-count options
##  consensus=>1   do not display the option "consensus as matrix name"
##  nowhere=>1     do not display the info "Where to find matrices"
##  db_choice=>1    display radio option to be combined with MatrixDB selection
sub GetMatrix {
  my (%args) = @_;
  my $db_choice= $args{'db_choice'} || 0;
  my $status_db_choice=$args{'status_db_choice'} || 0;
#  my $consensus = $args{consensus};
#  my $no_pseudo = $args{no_pseudo};
  $args{title}="Input personal collection of motifs" if ($db_choice);
  my $title = $args{title} || "Matrix (or matrices)";
  #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;
  print "<input type='radio' NAME='db_choice_radio' VALUE='custom_motif_db' $status_db_choice >" if ($db_choice);
  print "<B>", $title, "</B>\n";
  print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
  print "<A class='iframe' HREF='help.convert-matrix.html#io_format'><B>Format</B></a>&nbsp;";

  my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
                'homer' => 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
                'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
			       );
  ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
  ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
  ## I SHOULD CHECK LATER
  ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
  my @supported_input_formats = sort(keys( %supported_input_format));
  #  my $supported_input_formats = join ",", @supported_input_formats;
  #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);

  ## Matrix format
  print $query->popup_menu(-id=>'matrix_format',
			   -name=>'matrix_format',
			   -Values=>[@supported_input_formats],
			   -default=>$default{matrix_format});
  

  ## Display option fo use consensus as matrix name
  if ($args{consensus}) {
    print $query->checkbox(-id=>'consensus_as_name', -name=>'consensus_as_name',
			   -checked=>$default{consensus_as_name},
			   -label=>' use motif consensus as matrix name ');
  }

  ## Text area to enter the matrix
  print "<BR>\n";
  print  "Input motifs as text<br/>" if ($db_choice);
  print "<div>";


  print $query->textarea(-id=>'matrix',
    -name=>'matrix',
			 -default=>$default{matrix},
			 -rows=>4,
			 -columns=>60);


  ## Option to upload the matrix file from the client machine
  print "<BR>\n";
  print  "Upload motifs file<br/>" if ($db_choice);
  print "<b>Or</b> select a file to upload <BR>\n" unless ($db_choice);
  print $query->filefield(-name=>'uploaded_file_matrix',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);

    ## Propose help to find matrices
    unless ($args{nowhere}) {
        print "<br/><br/>";
        &MotifSelection('ids' => 1);
    }
    
  ## Display additional options: pseudo-count and pseudo-count distribution
  unless ($args{no_pseudo}) {
    #### pseudo-counts
    print "<BR>\n";
    print "<B><A class='iframe' HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
    print $query->textfield(-id=>'pseudo_counts', -name=>'pseudo_counts',
			    -default=>$default{pseudo_counts},
			    -size=>2);
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");
  }
}

sub GetFirstMatrix {
    my (%args) = @_;
    my $db_choice= $args{'db_choice'} || 0;
    my $status_db_choice=$args{'status_db_choice'} || 0;
    #  my $consensus = $args{consensus};
    #  my $no_pseudo = $args{no_pseudo};
    $args{title}="Input personal collection of motifs" if ($db_choice);
    my $title = $args{title} || "Matrix (or matrices)";
    #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;
    print "<input type='radio' NAME='db_choice' VALUE='custom_motif_db' $status_db_choice >" if ($db_choice);
    print "<B>", $title, "</B>\n";
    print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
    print "<A class='iframe' HREF='help.convert-matrix.html#io_format'><B>Format</B></a>&nbsp;";
    
    my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
    'homer' => 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
    'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
    );
    ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
    ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
    ## I SHOULD CHECK LATER
    ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
    my @supported_input_formats = sort(keys( %supported_input_format));
    #  my $supported_input_formats = join ",", @supported_input_formats;
    #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);
    
    ## Matrix format
    print $query->popup_menu(-id=>'matrix_format1',
			     -name=>'matrix_format1',
			     -Values=>[@supported_input_formats],
			     -default=>$default{matrix_format});
    
    
    ## Display option fo use consensus as matrix name
    if ($args{consensus}) {
        print $query->checkbox(-id=>'consensus_as_name', -name=>'consensus_as_name',
        -checked=>$default{consensus_as_name},
        -label=>' use motif consensus as matrix name ');
    }
    
    ## Text area to enter the matrix
    print "<BR>\n";
    print  "Input motifs as text<br/>" if ($db_choice);
    print "<div>";
    
    
    print $query->textarea(-id=>'matrix1',
    -name=>'matrix1',
			 -default=>$default{matrix},
			 -rows=>4,
			 -columns=>60);
    
    ## Option to upload the matrix file from the client machine
    print "<BR>\n";
    print  "Upload motifs file<br/>" if ($db_choice);
    print "<b>Or</b> select a file to upload <BR>\n" unless ($db_choice);
    print $query->filefield(-name=>'uploaded_file_matrix1',
    -default=>'',
    -size=>45,
    -maxlength=>200);
    
    ## Propose help to find matrices
    unless ($args{nowhere}) {
        print "<br/><br/>";
        &MotifSelection('ids' => 1);
    }
    #print "<BR>\n";
    
    
    ## Display additional options: pseudo-count and pseudo-count distribution
    unless ($args{no_pseudo}) {
        #### pseudo-counts
        print "<BR>\n";
        print "<B><A class='iframe' HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
        print $query->textfield(-id=>'pseudo_counts', -name=>'pseudo_counts',
        -default=>$default{pseudo_counts},
        -size=>2);
        print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
        print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");
    }
}

######### bootstrap version #######
sub GetMatrix_bootstrap {
  my (%args) = @_;
  my $db_choice= $args{'db_choice'} || 0;
  my $status_db_choice=$args{'status_db_choice'} || 0;
#  my $consensus = $args{consensus};
#  my $no_pseudo = $args{no_pseudo};
  $args{title}="Input personal collection of motifs" if ($db_choice);
  my $title = $args{title} || "Matrix (or matrices)";
  #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;

  print "<input type='radio' NAME='db_choice' VALUE='custom_motif_db' $status_db_choice >" if ($db_choice);


  my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
                'homer' => 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
                'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
			       );
  ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
  ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
  ## I SHOULD CHECK LATER
  ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
  my @supported_input_formats = sort(keys( %supported_input_format));
  #  my $supported_input_formats = join ",", @supported_input_formats;
  #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);
print '<div class="form-inline"> <div class="form-group">\n';

  print "<label for='matrix_format'>", $title, "</label>\n";
  print "<A class='badge badge-primary iframe' HREF='help.convert-matrix.html#io_format' >Info</a>";

  print '';

  ## Matrix format
  print $query->popup_menu(-id=>'matrix_format',
			   -name=>'matrix_format',
			   -Values=>[@supported_input_formats], -class=>'form-control',
			   -default=>$default{matrix_format});
  

  ## Display option fo use consensus as matrix name
  if ($args{consensus}) {
    print $query->checkbox(-id=>'consensus_as_name', -name=>'consensus_as_name', -class=>'form-check-input',
			   -checked=>$default{consensus_as_name},
			   -label=>' use motif consensus as matrix name ');
  }

print '</div></div>
<div class="form-group">';
  ## Text area to enter the matrix
  print  "Input motifs as text<br/>" if ($db_choice);
  print '<div>

   ';

  print $query->textarea(-id=>'matrix',
    -name=>'matrix', -class=>'form-control',-placeholder=>'Paste here your matrices, or select a file to upload below ',
			 -default=>$default{matrix},
			 -rows=>4,
			 -columns=>60);

print '</div>';

  ## Option to upload the matrix file from the client machine
  print  "Upload motifs file<br/>" if ($db_choice);
  print "<b>Or</b> select a file to upload <BR>\n" unless ($db_choice);
  print $query->filefield(-name=>'uploaded_file_matrix',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
  ## Propose help to find matrices
  unless ($args{nowhere}) {
    print "<br/><br/>";
    &MotifSelection('ids' => 1);
  }
  
    print "<BR></div>\n";
  ## Display additional options: pseudo-count and pseudo-count distribution
  unless ($args{no_pseudo}) {
    #### pseudo-counts
    print "<BR>\n";
    print "<B><A class='iframe' HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
    print $query->textfield(-id=>'pseudo_counts', -name=>'pseudo_counts',
			    -default=>$default{pseudo_counts},
			    -size=>2);
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");
  }

}

#################################
## Multiple Matrix choice
######### bootstrap version #######
sub MultiGetMatrix_bootstrap {
  my (%args) = @_;
  my $db_choice= $args{'db_choice'} || 0;
  my $status_db_choice=$args{'status_db_choice'} || 0;
#  my $consensus = $args{consensus};
#  my $no_pseudo = $args{no_pseudo};
  $args{title}="Input personal collection of motifs" if ($db_choice);
  my $title = $args{title} || "Matrix (or matrices)";
  my $mat_num = $args{mat_num};
  #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;

  print "<input type='radio' NAME='db_choice' VALUE='custom_motif_db' $status_db_choice >" if ($db_choice);


  my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
                'homer' => 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
                'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
			       );
  ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
  ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
  ## I SHOULD CHECK LATER
  ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
  my @supported_input_formats = sort(keys( %supported_input_format));
  #  my $supported_input_formats = join ",", @supported_input_formats;
  #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);
  print '<div class="form-inline"> <div class="form-group">';
  print "\n";

  print "<label for='matrix_format".$mat_num."'>", $title, "</label>\n";
  print "<A class='badge badge-primary iframe' HREF='help.convert-matrix.html#io_format' >Info</a>";
  
  print '';
  
  #### matrix format
  print $query->popup_menu(-id=>'matrix_format'.$mat_num,
    -name=>'matrix_format'.$mat_num,
			   -Values=>[@supported_input_formats], -class=>'form-control',
			   -default=>$default{"matrix_format".$mat_num});


  ## Display option fo use consensus as matrix name
  if ($args{consensus}) {
    print $query->checkbox(-id=>'consensus_as_name'.$mat_num, -name=>'consensus_as_name'.$mat_num, -class=>'form-check-input',
			   -checked=>$default{"consensus_as_name".$mat_num},
			   -label=>' use motif consensus as matrix name ');
  }

  print '</div></div>
<div class="form-group">';
  print "\n";
  ## Text area to enter the matrix
  print  "Input motifs as text<br/>" if ($db_choice);
  print '<div>

   ';

  print $query->textarea(-id=>'matrix'.$mat_num,
			 -name=>'matrix'.$mat_num, 
			 -class=>'form-control',
			 -placeholder=>'Paste here your matrices, or select a file to upload below ',
			 -default=>$default{"matrix".$mat_num},
			 -rows=>4,
			 -columns=>60);

  print '</div>';
  
  ## Option to upload the matrix file from the client machine
  print  "Upload motifs file<br/>" if ($db_choice);
  print "<b>Or</b> select a file to upload <BR>\n" unless ($db_choice);
  print $query->filefield(-name=>'uploaded_file_matrix'.$mat_num,
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
  print "<BR></div>\n";
  
}


###############################################################
### Select a motif collection
sub MotifSelection {
    my (%args) = @_;
    print '<link rel="stylesheet" href="css/select2.min.css" /><script src="js/select2.full.min.js"></script>';
    print '<style>.select2-results__options {font-size:10px} </style>';
    print '<script type="text/javascript" src="js/retrieve_matrix.js">

    </script>';

    print '<style> input.select2-search__field { width: 90% !important; } </style>';
    print '<div style="float:left;font-size:11px">';
    if($args{ids} == 1){
        print "<b>Or</b> Dynamic selection of motifs from the available collections</b> <img src='images/onebit_49.png' height='30' class='new'/><br/><span style='font-size:10px'>(select the collection and a dropdown menu will appear to select motifs)</span><br/><br/>";
    }
    my $width = ($args{ids} == 1) ? "300px" : "400px";
    my $multiple = ($args{mode} eq 'checkbox') ? 'multiple="multiple"' : '';
    my $select_id = ($args{more} == 1) ? 'db_choice2' : 'db_choice';
    my $select_ids = ($args{more} == 1) ? 'dbs_choice2' : 'dbs_choice';
    print "<table><tr><td style='padding-right:20px'><b>Input</b></td>";
    
    print "<td align='top'>1 - Select a database in list:<br/>";
    print " <select id='$select_ids' name='$select_ids' $multiple style='width:$width'><option></option>";
    ## load the various databases that can be compared against
    &DisplayMatrixDBchoice("mode"=>"radio");
    print "</select>";
    print "<td align='top'>2 - Select a collection in list:<br/>";
    print " <select id='$select_id' name='$select_id' $multiple style='width:$width'><option></option>";
    ## load the various databases that can be compared against
    print '</select>';
    
    print "</td>";
    if($args{ids} == 1){
        print "<td align='top'>";
        print "3 - Select one or more matrix identifiers:<br/>";
        print " <select id='db_id' style='width:300px' multiple='multiple'></select>";
    }
    print '<div style="clear:both;"></div>';
    print "</td><td><div id='wait_ids' style='display:none'><image src='images/wait.gif' style='width:50px;height:50px' /></div></td></tr></table>";
    if($args{more} != 1){
        print '<br/><a class="inline" href="#matrix_descr""> View matrix descriptions & download full collections</a> <br/>';
        print "<div style='display:none'><div id='matrix_descr'>";
        &DisplayMatrixDBchoice("mode" => "list");
        print "</div></div>";
    }
    print "</div>";
    
    print '<div style="clear:both;"></div>';
}

################################################################
################################################################
sub GetSecondMatrix {
  my (%args) = @_;
  my $db_choice= $args{'db_choice'} || 0;
  my $status_db_choice=$args{'status_db_choice'} || 0;
#  my $consensus = $args{consensus};
#  my $no_pseudo = $args{no_pseudo};
  $args{title}="Input personal collection of motifs" if ($db_choice);
  my $title = $args{title} || "Matrix (or matrices)";
  #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;
  print "<input type='radio' NAME='db_choice' VALUE='custom_motif_db'  $status_db_choice >" if ($db_choice);
  print "<B>", $title, "</B>\n";
  print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
  print "<A HREF='help.convert-matrix.html#io_format'><B>Format</B></a>&nbsp;";


  my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
      				'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
			       );
  ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
  ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
  ## I SHOULD CHECK LATER
  ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
  my @supported_input_formats = sort(keys( %supported_input_format));
  #  my $supported_input_formats = join ",", @supported_input_formats;
  #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);

  ## Second matrix format
  print $query->popup_menu(-name=>'matrix_format2',
			   -id=>'matrix_format2',
			   -Values=>[@supported_input_formats],
			   -default=>$default{matrix_format});


  ## Display option fo use consensus as matrix name
  if ($args{consensus}) {
    print $query->checkbox(-name=>'consensus_as_name',
			   -checked=>$default{consensus_as_name},
			   -label=>' use motif consensus as matrix name ');
  }

  ## Text area to enter the matrix
  print "<BR>\n";
  print  "Input motifs as text<br/>" if ($db_choice);
  print "<div><div style='float:left;'>";
  print $query->textarea(-name=>'matrix2', -id=>'matrix2',
			 -default=>$default{matrix_2},
			 -rows=>4,
			 -columns=>60);

  ## Option to upload the matrix file from the client machine
  print "<BR>\n";
  print  "Upload motifs file<br/>" if ($db_choice);
  print "Or select a file to upload <BR>\n" unless ($db_choice);
  print $query->filefield(-name=>'uploaded_file_matrix2',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
    print "<BR>\n";

  ## Propose help to find matrices
  unless ($args{nowhere}) {
    print '</div><div class="menu">
<div class="menu_heading_closed"
onclick="toggleMenu(';
    print "'98'";
    print ')" id="heading98"> Where to find matrices ?</div>
<div id="menu98" class="menu_collapsible">
	<a class="menu_item" href="http://www.pazar.info/" target="_blank">PAZAR</a>
	<a class="menu_item" href="http://the_brain.bwh.harvard.edu/uniprobe/" target="_blank">UniProbe</a>
	<a class="menu_item" href="http://www.gene-regulation.com/pub/databases.html" target="_blank">Transfac</a>
	<a class="menu_item" href="http://jaspar.cgb.ki.se/" target="_blank">Jaspar</a>
	<a class="menu_item" href="http://regulondb.ccg.unam.mx/download/Data_Sets.jsp" target="_blank">RegulonDB</a>

</div>
</div>
</div>
</div>
<div style="clear:both;"></div>
';
  }

  ## Display additional options: pseudo-count and pseudo-count distribution
  unless ($args{no_pseudo}) {
    #### pseudo-counts
    print "<BR>\n";
    print "<B><A HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
    print $query->textfield(-name=>'pseudo_counts',
			    -default=>$default{pseudo_counts},
			    -size=>2);
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");
  }
}

sub GetSecondMatrixFile {
  my ($matrix_file_2) = @_ ;

  ################################################################
  ## Upload sequence file from the client
  my $upload_file_2 = $query->param('uploaded_file_matrix_2');
  if ($upload_file_2) {

    $type = $query->uploadInfo($upload_file_2)->{'Content-Type'};
    open MAT, ">$matrix_file_2" ||
      &cgiError("Cannot store matrix file in temp dir.");
    while (<$upload_file>) {
      print MAT;
    }
    close MAT;

    ### Fetch sequence from an URL
  } elsif ($query->param('matrix2') =~ /\S/) {
    if (open MAT, ">$matrix_file_2") {
       print MAT $query->param('matrix2');
      close MAT;
    }

  }

  #### sequence file will be deleted
  &DelayedRemoval($matrix_file_2);

  return($matrix_file_2);
}
################################################################
################################################################

sub GetThirdMatrix {
  my (%args) = @_;
  my $db_choice= $args{'db_choice'} || 0;
  my $status_db_choice=$args{'status_db_choice'} || 0;
#  my $consensus = $args{consensus};
#  my $no_pseudo = $args{no_pseudo};
  $args{title}="Input personal collection of motifs" if ($db_choice);
  my $title = $args{title} || "Matrix (or matrices)";
  #print "<a href=''><b>Use your own motifs collection:</b></a><br/>" ;
  print "<input type='radio' NAME='db_choice' VALUE='custom_motif_db'  $status_db_choice >" if ($db_choice);
  print "<B>", $title, "</B>\n";
  print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
  print "<A HREF='help.convert-matrix.html#io_format'><B>Format</B></a>&nbsp;";


  my %supported_input_format = (
				'alignace'=> 1,
				'assembly'=>1,
				'clustal'=>1,
				'cluster-buster'=>1,
				'consensus'=>1,
				'feature'=>1,
				'footprintDB'=>1,
				'gibbs'=> 1,
				'infogibbs'=>1,
				'jaspar'=>1,
				'mscan'=>1,
				'meme'=>1,
				'meme_block'=>1,
				'motifsampler'=>1,
				'sequences' => 1,
				'stamp'=>1,
				'stamp-transfac'=>1,
      				'cis-bp'=>1,
				'tab'=>1,
				'transfac'=>1,
				'uniprobe'=>1,
				'encode'=>1,
			       );
  ## THIS DOES NOT WORK, I DON'T UNDERSTAND WHY (JvH)
  ## THE STRANGEST THING IS THAT THE SAME WORKS FOR OUTPUT MATRICES IN convert-matrix_form.cgi
  ## I SHOULD CHECK LATER
  ##  my %supported_input_format =  %RSAT::MatrixReader::supported_input_format;
  my @supported_input_formats = sort(keys( %supported_input_format));
  #  my $supported_input_formats = join ",", @supported_input_formats;
  #  &RSAT::message::Warning("supported input formats:", $supported_input_formats);

  ## Third matrix format
  print $query->popup_menu(-name=>'matrix_format3',
			   -id=>'matrix_format3',
			   -Values=>[@supported_input_formats],
			   -default=>$default{matrix_format});


  ## Display option fo use consensus as matrix name
  if ($args{consensus}) {
    print $query->checkbox(-name=>'consensus_as_name',
			   -checked=>$default{consensus_as_name},
			   -label=>' use motif consensus as matrix name ');
  }

  ## Text area to enter the matrix
  print "<BR>\n";
  print  "Input motifs as text<br/>" if ($db_choice);
  print "<div><div style='float:left;'>";
  print $query->textarea(-name=>'matrix3', -id=>'matrix3',
			 -default=>$default{matrix_3},
			 -rows=>4,
			 -columns=>60);

  ## Option to upload the matrix file from the client machine
  print "<BR>\n";
  print  "Upload motifs file<br/>" if ($db_choice);
  print "Or select a file to upload <BR>\n" unless ($db_choice);
  print $query->filefield(-name=>'uploaded_file_matrix3',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
    print "<BR>\n";

  ## Propose help to find matrices
  unless ($args{nowhere}) {
    print '</div><div class="menu">
<div class="menu_heading_closed"
onclick="toggleMenu(';
    print "'98'";
    print ')" id="heading98"> Where to find matrices ?</div>
<div id="menu98" class="menu_collapsible">
	<a class="menu_item" href="http://www.pazar.info/" target="_blank">PAZAR</a>
	<a class="menu_item" href="http://the_brain.bwh.harvard.edu/uniprobe/" target="_blank">UniProbe</a>
	<a class="menu_item" href="http://www.gene-regulation.com/pub/databases.html" target="_blank">Transfac</a>
	<a class="menu_item" href="http://jaspar.cgb.ki.se/" target="_blank">Jaspar</a>
	<a class="menu_item" href="http://regulondb.ccg.unam.mx/download/Data_Sets.jsp" target="_blank">RegulonDB</a>

</div>
</div>
</div>
</div>
<div style="clear:both;"></div>
';
  }

  ## Display additional options: pseudo-count and pseudo-count distribution
  unless ($args{no_pseudo}) {
    #### pseudo-counts
    print "<BR>\n";
    print "<B><A HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
    print $query->textfield(-name=>'pseudo_counts',
			    -default=>$default{pseudo_counts},
			    -size=>2);
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
    print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");
  }
}

sub GetThirdMatrixFile {
  my ($matrix_file_3) = @_ ;

  ################################################################
  ## Upload sequence file from the client
  my $upload_file_3 = $query->param('uploaded_file_matrix_3');
  if ($upload_file_3) {

    $type = $query->uploadInfo($upload_file_3)->{'Content-Type'};
    open MAT, ">$matrix_file_3" ||
      &cgiError("Cannot store matrix file in temp dir.");
    while (<$upload_file>) {
      print MAT;
    }
    close MAT;

    ### Fetch sequence from an URL
  } elsif ($query->param('matrix_3') =~ /\S/) {
    if (open MAT, ">$matrix_file_3") {
       print MAT $query->param('matrix_3');
      close MAT;
    }

  }

  #### sequence file will be deleted
  &DelayedRemoval($matrix_file_3);

  return($matrix_file_3);
}
################################################################
################################################################


################################################################
##
## Inspired from GetSequenceFile
## To eanble loading matrices via a file instead of copy / paste
##
sub GetMatrixFile {
  my ($matrix_file,$mat_num) = @_ ;

  ################################################################
  ## Upload sequence file from the client
  my $upload_file = $query->param('uploaded_file_matrix'.$mat_num);
  if ($upload_file) {

    $type = $query->uploadInfo($upload_file)->{'Content-Type'};
    open MAT, ">$matrix_file" ||
      &cgiError("Cannot store matrix file in temp dir.");
    while (<$upload_file>) {
      print MAT;
    }
    close MAT;

    ### Fetch sequence from an URL
  } elsif ($query->param('matrix'.$mat_num) =~ /\S/) {
    if (open MAT, ">$matrix_file") {
       print MAT $query->param('matrix'.$mat_num);
      close MAT;
    }

  } else {
      &cgiError("The matrix box should not be empty.");
  }

  #### sequence file will be deleted
  &DelayedRemoval($matrix_file);

  return($matrix_file);
}


################################################################
## Print the many scores supported by compare-matrices, which are also
## available for matrix-clustering.
sub PrintMatrixMatchingScores {
  my @matching_scores = qw(w
			 cor
			 Ncor
                         logoDP
			 logocor
			 Nlogocor
			 Icor
			 NIcor
			 cov
			 dEucl
			 NdEucl
			 NsEucl
			 SSD
			 SW
			 NSW
			 match_rank
			 offset
			);

  my %score_descriptions = ('w'=>'Width = number of aligned columns',
			    'cor'=>'Pearson correlation (computed on residue occurrences in aligned columns)',
			    'Ncor'=>'Relative width-normalized Pearson correlation',
			    'logoDP'=>'dot product of sequence logos',
			    'logocor'=>'correlation computed on sequence logos',
			    'Nlogocor'=>'Relative width-normalized logocor',
			    'Icor'=>'Pearson correlation computed on Information content',
			    'NIcor'=>'Relative width-normalized Icor',
			    'cov'=>'covariance between residues in aligned columns',
			    'dEucl'=>'Euclidian distance between residue occurrences in aligned columns',
			    'NdEucl'=>'Relative width-normalized dEucl',
			    'NsEucl'=>'similarity derived from Relative width-normalized Euclidian distance',
			    'SSD'=>'Sum of square deviations',
			    'SW'=>'Sandelin-Wasserman',
			    'NSW'=>'Relative width-normalized Sandelin-Wasserman',
			    'match_rank'=>'rank of current match among all sorted matches',
			    'offset'=>'offset between first and second matrices'
      );


  ## ##############################################################
  ## Other selectable output fields
  ##
  ## Note (JvH, 2014-05-15): I think these output fields are just
  ## ignored by compare-matrices, I should revise this.

  my @other_fields = qw(matrix_number
		      matrix_id
		      matrix_name
		      matrix_ac
		      strand
		      direction
		      pos
		      consensus
		      alignments_pairwise
		      alignments_1ton
		     );



  &ScoresAndThresholdsDiv("Matrix comparison scores and thresholds",
			  "help.compare-matrices.html#return_fields",
			  \@matching_scores,
			  \%score_descriptions);
}


################################################################
## Display a collapsable div with selectable scores and thresholds
sub ScoresAndThresholdsDiv {
  my ($title, $help_file, $field_ref, $field_descr_ref) = @_;

  print "<p class=\"clear\"></p>\n";
#  print "<div class=\"menu_heading_closed\" onclick=\"toggleMenu(\'101\')\" id=\"heading101\"><b>",$title,"</b>\n";
  print "<div class=\"menu_heading_closed\" onclick=\"toggleMenu(\'101\')\" id=\"heading101\"><b>",$title,"</b></div>\n";
  print "<div id=\"menu101\" class=\"menu_collapsible\">\n";
  print "<p><fieldset>\n";

  &FieldsThresholdsTable($help_file, $field_ref, $field_descr_ref);

  print "</fieldset></p>";
  print '</div><p class=\"clear\"></p>';
}


################################################################
## Display a table with checkboxes and thresholds for a set of
## specified fields
sub FieldsThresholdsTable {
  my ($help_file, $field_ref, $field_descr_ref, $no_checkbox) = @_;
  my @fields = @{$field_ref};
  my %field_descr = %{$field_descr_ref};
  print "<table align='center'>\n";
  print $query->th([" <A HREF='".$help_file."'>Output<br>fields</A> ",
		    " <A HREF='".$help_file."'>Lower<br>Threshold</A> ",
		    " <A HREF='".$help_file."'>Upper<br>Threshold</A> "]);
  foreach my $field (@fields) {
    my $lth = $default{'lth_'.$field} || "none";
    my $uth = $default{'uth_'.$field} || "none";

    print "<tr valign='middle'>";

    ## Print field name with or without checkbox
    if ($no_checkbox) {
	print "<td>", $field, "</td>\n";
    } else {
	print "<td>", $query->checkbox(-name=>'return_'.$field,-id=>'return_'.$field,
				       -checked=>$default{'return_'.$field},
				       -label=>''), "&nbsp;", $field, "</td>\n";
    }

    ## Lower threshold
    if (lc($lth) eq "disabled") {
	print "<td align='center'>&nbsp;</td>";
    } else {
	print "<td>", $query->textfield(-name=>'lth_'.$field,-id=>'lth_'.$field,
				-default=>$lth,
				-size=>5), "</td>\n";
    }

    ## Upper threshold
    if (lc($uth) eq "disabled") {
	print "<td>&nbsp;</td>";
    } else {
	print "<td>", $query->textfield(-name=>'uth_'.$field,-id=>'uth_'.$field,
				    -default=>$uth,
				    -size=>5), "</td>\n";
    }
    print "<td>", $field_descr{$field}, "</td>\n";
    print "</tr>\n";
  }
  print "</table>\n";
}


################################################################
## Display the options to select a background model for matrix-based
## programs.
##
## Parameters can change the options to be displayed.
##
## Usage: &GetBackgroundModel(%params);
##
## Supported parameters:
##   title=>'alternative title'  replace the title "Background model" by the specified title
##   title_choose=>1             display a radio button
##   simple=>1                   simplify the display
##   markov=>1                   display Markov order option
##   markov_message=>1           display message "higher orders can b time-consuming"
##   from_matrix=>1              display option to estimate BG model from input matrix
##   bg_input=>1                 display option to estimate BG model from input sequences
##   bg_window=>1                display option to estimate BG model from sliding window
##   taxon=>1                    display option to select taxon-specific BG models
##   strand=>1                   display option single/both strands
##   noov=>1                     display "no overlap" option
##   title2=>1                   display a second title ????
##   sep_bg_pseudo=>1            draw a horizontal line to separate bg pseudo options
##   no_bg_pseudo=>1             do not display bg pseudo option
sub GetBackgroundModel {
#  my ($params_ref) = shift;
  my %params = @_;
#  my $simple = shift;


  ## Title to display above background choice options
#  my $title = "Background model choice";
  my $title  = "<a class='iframe' href=help.matrix-scan.html#bg_method>Background model estimation method</a>";

  if ($params{title}) {
    $title = $params{title};
  }
  if ($params{title_choose}) {
    print ("<input type='radio' name='bg_choose' value='rsat' $checked{'rsat'}>");
    print "<b>$title</b><br/>";
  } else {
    print "<p><B>$title</B><br>";
  }

  print "<ul>";


  ################################################################
  #### Markov order

  ## BUG HERE: THE DEFAULT $default{markov_order} is not taken into account, the displayed order is always 0.
  ##  &RSAT::message::Debug("Default markov order", $default{markov_order});
  if ($params{markov}) {
    print ("<b><a class='iframe' href=help.matrix-scan.html#markov_order>Markov order</a></b> &nbsp;");
    if ($params{simple}) {
      print $query->popup_menu(-id=>'markov_order', 
			       -name=>'markov_order',
			       -Values=>[0..2],
			       -default=>$default{markov_order});
    } else {
      print $query->popup_menu(-id=>'markov_order', 
			       -name=>'markov_order',
			       -Values=>[0..7],
			       -default=>$default{markov_order});
    }
    if ($params{markov_message}) {
      print ("&nbsp;&nbsp;&nbsp;<font color='orange'>High orders can be time-consuming, but order 0 is generally not representative</font>. We recommend orders 1 or 2.");
    }
  }

  ## Display option to estimate BG model from input sequences
  if ($params{bg_input}) {
    #### Input sequences
    print ("<br><input type='radio' name='bg_method' id='bg_method_bginput' value='bginput' $checked{'bginput'}>","<b>Estimate residue probabilities from input sequences</b>");
  }

  ## Display option to estimate BG model from sliding window
#  if ($params{bg_window}) {
#    ## Sliding window
#    print ("<br><input type='radio' NAME='bg_method' VALUE='window' $checked{'window'}>","<b>Sliding window</b> &nbsp;");
#    print $query->textfield(-name=>'window_size',
#			    -default=>$default{window_size},
#			    -size=>5);
#  }


  ## Display option to select organism- and taxon-specific BG models
  #### Sequence type for organism- an taxon-specific background models
  print "<p>";
  unless ($params{title_choose}) {
    print ("<input type='radio' name='bg_method' id='bg_method_bgfile' value='bgfile' $checked{bgfile}>");
  }
  print '<b>Organism-specific</b>';
  print '<ul>';
  if ($params{taxon}) {
    #    print  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    print "<input type='radio' NAME='bg_taxo' VALUE='organism' $checked{organism}>";
    print &OrganismPopUpString('bg_org' => '1');
    print  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
    print "<input type='radio' NAME='bg_taxo' VALUE='taxon' $checked{taxon}>";
    print &TaxonPopUp();

  } else {
    print  &OrganismPopUpString('bg_org'=>'1');
  }

    print ("<b>Sequence type</b> &nbsp; ",
	   $query->popup_menu(-id=>'background',
			      -name=>'background',
			      -Values=>["upstream-noorf","upstream"],
			      -default=>$default{background}));

  print '</ul>';


  ## Display option to estimate BG model from input matrix
  if ($params{from_matrix}) {
    print ("<br><input type='radio' NAME='bg_method' VALUE='from_matrix' $checked{'from_matrix'}>","<b>Estimate from input matrix</b>");
  }


  ### Display strand option
  if ($params{strands}) {
    print "<B><A class='iframe' HREF='help.convert-background-model.html#item__2d1str'><br>Count on</A></b>\n";
    print $query->popup_menu(-id=>'strands',
			     -name=>'strands',
			     -Values=>[
				'single strand',
				'both strands',
			     ],
			     -default=>$default{strands});
    print "&nbsp;&nbsp";
  }


  ## Display "no overlap" option
  if ($params{noov}) {
    print ($query->checkbox(-name=>'noov',-checked=>$default{noov},-label=>''));
    print "<B><A class='iframe' HREF='help.convert-background-model.html#item__2dnoov'>prevent overlapping matches (noov)</A></b>\n";
    print "<br/>";
  }


  print "</ul>";


  ## Display a second title ????
  if ($params{title2}) {
    if ($params{title_choose}) {
#      print "<p><b> OR <b></p>";
      print ("<p/><input type='radio' NAME='bg_choose' VALUE='file_upload' $checked{'file_upload'}>");
    }
    print "<b>$params{title2}</b><br>";
  }

  #### custom background model
  unless ($params{simple}) {
    print "<ul>\n";
    &DisplayBackgroundFileUpload();
    print "</ul>\n";

    #### Pseudo-frequencies for the BG model
    unless ($params{no_bg_pseudo}) {
      ## Draw a horizontal line to separate bg pseudo options
      if ($params{sep_bg_pseudo}) {
	print "<hr/>";
      }

      print "<p/>\n";
      print "<B><A class='iframe' HREF='help.matrix-scan.html'>Pseudo-frequencies</A></b>\n";
      print $query->textfield(-name=>'bg_pseudo',
			      -default=>$default{bg_pseudo},
			      -size=>5);
    }
  }
}

################################################################
## Display the list of supported background formats and a textbox or
## file upload.
sub DisplayBackgroundFileUpload {
    #unless ($params{title_choose}) {
    #}
    print "<b><a class='iframe' href=help.convert-background-model.html>Input your own background file</a></b> &nbsp;";
   # print "<b>Input your own background file", "&nbsp;"x5;
    print "<br/><b>&nbsp;&nbsp;&nbsp;&nbsp;<a class='iframe' href='help.convert-background-model.html'>Format</a></b>&nbsp;";


      #### bg format
    print $query->popup_menu(-id=>'bg_format',
			     -name=>'bg_format',
			     -Values=>[
				'oligo-analysis',
				'MotifSampler',
				'meme'
			     ],
			     -default=>$default{bg_format});


    print "<br/><input type='radio' NAME='bg_method' VALUE='file_upload' $checked{file_upload}>";
    print "File Upload", "&nbsp;"x5;



    print $query->filefield(-name=>'upload_bgfile',
			    -default=>'starting value',
			    -size=>30,
			    -maxlength=>200);

    print "&nbsp;"x3;
     #unless ($params{title_choose}) {
    print "<br/><input type='radio' NAME='bg_method' id='url' VALUE='file_url' $checked{file_url}>";
    #}
    print  "URL of file available on a Web server.<br>\n";
    print  $query->textfield(-name=>'bgmodel_url', -id => 'bgmodel_url',
			     -default=>$default{'bgmodel_url'},
			     -size=>62);
    print "<br/>\n"
}


################################################################
## Background model method
sub SetBackgroundModel {
  local $bg_method = $query->param('bg_method');
  if ($bg_method eq "from_matrix") {

  } elsif ($bg_method eq "bgfile") {
    ## Select pre-computed background file in RSAT genome directory
    local $organism_name = $query->param("organism_bg");
    local $noov = "ovlp";
    local $background_model = $query->param("background");
    local $oligo_length = 1;
    $bg_file = &ExpectedFreqFile($organism_name,
				 $oligo_length, $background_model,
				 noov=>$noov, str=>"-1str");
    $parameters .= " -bgfile ".$bg_file;
    $parameters .= " -bg_format oligos";

  } elsif ($bg_method =~ /upload/i) {
    ## Upload user-specified background file
    local $bgfile = $tmp_file_path."_bgfile.txt";
    local $upload_bgfile = $query->param('upload_bgfile');
    if ($upload_bgfile) {
      if ($upload_bgfile =~ /\.gz$/) {
	$bgfile .= ".gz";
      }
      local $type = $query->uploadInfo($upload_bgfile)->{'Content-Type'};
      open BGFILE, ">$bgfile" ||
	&cgiError("Cannot store background file in temp dir.");
      while (<$upload_bgfile>) {
	print BGFILE;
      }
      close BGFILE;
      $parameters .= " -bgfile $bgfile";
      $parameters .= " -bg_format ".$query->param('bg_format');
    } else {
      &FatalError ("If you want to upload a background model file, you should specify the location of this file on your hard drive with the Browse button");
    }
  } else {
    &RSAT::error::FatalError($bg_method," is not a valid method for background specification");
  }
}

################################################################
## DisplayMatrixDBchoice
##
## Display a list of supported motif databases (ex: Jaspar).
##
## The argument "mode" allows to specify two alternative choice modes:
## "radio" (radio buttons) or "checkbox" (checkbox).
sub DisplayMatrixDBchoice {
    my (%args) = @_;
    ## Check selection mode
    my $mode = $args{mode} || "checkbox"; ## Display check boxes or radio buttons
    my %supported_choice_mode = ("radio"=>1, "checkbox"=>1, "list"=>1);
    my $supported_choice_modes = join ",", sort keys %supported_choice_mode;
    
    &RSAT::error::FatalError($mode, "Invalid choice mode for &DisplayMatrixDBchoice(). Supported: ".$supported_choice_modes)
    unless ($supported_choice_mode{$mode});
    
    ## Get information about supported motif databases
    my %matrix_db = &RSAT::server::supported_motif_databases_2();
    
    my %colors = (
    'Vertebrates' => 'blue',
    'Non-vertebrate Metazoa' => 'orange',
    'Plants' => 'green',
    'Fungi' => 'purple',
    'Prokaryotes' => 'teal',
    'Multi-organisms' => 'yellow',
    'RNA binding' => 'coral'
    );
    
    my @multicategory = ();
    my %singlecategory = ();
    ## Display supported motif databases
    foreach my $dbs_name (keys (%matrix_db)) {
        if($mode eq "radio"){
            ## check number of categories
            my @cats = ();
            foreach my $key (keys %{$matrix_db{$dbs_name}}){
                my %db = %{$matrix_db{$dbs_name}{$key}};
                if(! ($db{category} ~~ @cats)){ push @cats, $db{category};}
            }
            if(scalar @cats == 1){
                my $cat = $cats[0];
                if(! defined $singlecategory{$cat}) { $singlecategory{$cat} = (); }
                push @{$singlecategory{$cat}}, $dbs_name;
            }else{
                push @multicategory, $dbs_name;
            }
        }
    }
    
    if($mode eq "radio"){
        print "<optgroup label='Multi-categories'>";
        foreach my $key (sort {"\L$a" cmp "\L$b"} @multicategory){
            print "<option value='$key' class='pink'>$key</option>";
        }
        print "</optgroup>";
        foreach my $key (sort {"\L$a" cmp "\L$b"} (keys %singlecategory)){
            print "<optgroup label='$key'>";
            foreach my $db ( sort {"\L$a" cmp "\L$b"} @{$singlecategory{$key}}){
                print "<option value='$db' class='$colors{$key}'>$db</option>";
            }
            print "</optgroup>";
        }
    }else{
        
        my %matrix_db_cat = ();
        foreach my $key (keys %matrix_db){
            foreach my $db (keys %{$matrix_db{$key}}){
                my %db = %{$matrix_db{$key}{$db}};
                if(! defined $matrix_db_cat{$db{category}}){ $matrix_db_cat{$db{category}} = (); }
                push @{$matrix_db_cat{$db{category}}}, \%db;
            }
        }
        
        foreach my $key (sort {"\L$a" cmp "\L$b"} (keys %matrix_db_cat)){
            if($key ne ""){
                print "<h3 style='padding:10px'>$key</h3><div style='padding-left:50px;padding-top:15px'>";
                foreach my $db (@{$matrix_db_cat{$key}}){
                    my $file = ${$db}{file};
                    my $descr = ${$db}{descr};
                    
                    open (my $fh, "<", $ENV{RSAT}. "/public_html/motif_databases/" . $file);
                    my $nbmotif = 0;
                    while (my $row = <$fh>){
                        if($row =~ /^AC\s+/){
                            $nbmotif += 1;
                        }
                    }
                    if (${$db}{url}) {
                        $descr = "<a target='_blank' href=".${$db}{url}.">".$descr."</a>";
                    }
                    $descr .= " - [$nbmotif motifs] (".${$db}{version}.")";;
                    
                    $descr .= " - [<a href='$ENV{'www-rsat'}/rsat/motif_databases/$file' target='_blank' title='TRANSFAC format'>local copy</a>]<br/>";
                    print $descr;
                }
                print "</div>";
            }
        }
    }
}

sub DisplayMatrixDBchoice_select2 {
    my (%args) = @_;

    ## Check selection mode
    my $mode = $args{mode} || "checkbox"; ## Display check boxes or radio buttons
    my %supported_choice_mode = ("radio"=>1, "checkbox"=>1, "list"=>1);
    my $supported_choice_modes = join ",", sort keys %supported_choice_mode;
    &RSAT::error::FatalError($mode, "Invalid choice mode for &DisplayMatrixDBchoice(). Supported: ".$supported_choice_modes)
    unless ($supported_choice_mode{$mode});


    ## Get information about supported motif databases
    my %matrix_db = &RSAT::server::supported_motif_databases_2();
    
    ## declare the variables
    my @values;
    my @labels;
    my @colors;
    
    ## adapt for server-specific motifs
    if ($ENV{group_specificity} eq "Metazoa") {
    	@values = (\%vertebrates, \%metazoa, \%multi_organism);
    	@labels = ('Vertebrates', 'Non-vertebrate Metazoa', 'Multi-organisms','RNA binding');
    	@colors = ('blue', 'orange', 'yellow');
    
    } elsif ($ENV{group_specificity} eq "Fungi") {
    
    @values = (\%fungi, \%multi_organism);
    @labels = ( 'Fungi', 'Multi-organisms','RNA binding');
    @colors = ( 'purple', 'yellow');  

 	} elsif ($ENV{group_specificity} eq "Prokaryotes") {
    
    @values = (\%prokaryots, \%multi_organism);
    @labels = ('Prokaryotes', 'Multi-organisms','RNA binding');
    @colors = ('teal', 'yellow'); 
    
    } elsif ($ENV{group_specificity} eq "Plants") {
    
    @values = ( \%plants, \%multi_organism);
    @labels = ( 'Plants', 'Multi-organisms','RNA binding');
    @colors = ( 'green', 'yellow'); 
    
    } else {
    
    @values = (\%vertebrates, \%metazoa, \%plants, \%fungi, \%prokaryots, \%multi_organism);
    @labels = ('Vertebrates', 'Non-vertebrate Metazoa', 'Plants', 'Fungi', 'Prokaryotes', 'Multi-organisms','RNA binding');
    @colors = ('blue', 'orange', 'green', 'purple', 'teal', 'yellow','coral');  
    }
    
    ## Display supported motif databases
    foreach my $db_name (sort(keys (%matrix_db))) {
        my $db_format = $matrix_db{$db_name}->{'format'};
        my $descr = $matrix_db{$db_name}->{'descr'};
        my $version = $matrix_db{$db_name}->{'version'};
        my $url = $matrix_db{$db_name}->{'url'};
        my $file = $matrix_db{$db_name}->{'file'};
        my $label = $matrix_db{$db_name}->{'label'};

        for(my $i = 0; $i < scalar @labels; $i++){
                if($label eq $labels[$i]){
                    if($mode eq "list"){
                        open (my $fh, "<", $ENV{RSAT}. "/public_html/motif_databases/" . $file);
                        my $nbmotif = 0;
                        while (my $row = <$fh>){
                            if($row =~ /^AC\s+/){
                                $nbmotif += 1;
                            }
                        }
                        if ($url) {
                            $descr = "<a target='_blank' href=".$url.">".$descr."</a>";
                        }
                        $descr .= " - [$nbmotif motifs]";
                    }
                    ${$values[$i]}{$db_name} = $descr . " (".$version.")";
                    if($mode eq "list") {
                        ${$values[$i]}{$db_name} .= " - [<a href='$ENV{'www-rsat'}/rsat/motif_databases/$file' target='_blank' title='TRANSFAC format'>local copy</a>]";
                    }
            }
        }
    }
    for(my $i = 0; $i < scalar @values; $i++){
        if(! ($mode eq "list")){
            print "<optgroup label='$labels[$i]'>";
            foreach my $key (sort(keys %{$values[$i]})){
                print "<option value='$key' class='$colors[$i]'>${$values[$i]}{$key}</option>";
            }
            print "</optgroup>";
        }elsif($mode eq "list") {
            print "<h3 style='padding:10px'>$labels[$i]</h3><div style='padding-left:50px;padding-top:15px'>";
            foreach my $key (sort(keys %{$values[$i]})){
                print "${$values[$i]}{$key}<br/>";
            }
            print "</div>";
        }
    }
}


################################################################
## GetMatrixDBchoice
##
## Return motif database(s) selected in the list of supported motif databases.
##
## Options:
##   mode="radio" | mode="checkbox"
sub GetMatrixDBchoice {
  my (%args) = @_;
  my $matrix_db_params ="";
  my @selected_db = ();

  ## Check selection mode
  my $mode = $args{mode} || "checkbox"; ## Display check boxes or radio buttons
  my %supported_choice_mode = ("radio"=>1, "checkbox"=>1);
  my $supported_choice_modes = join ",", sort keys %supported_choice_mode;
  &RSAT::error::FatalError($mode, "Invalid choice mode for &GetMatrixDBchoice(). Supported: ".$supported_choice_modes)
      unless ($supported_choice_mode{$mode});

  ## Load the file containing the description and path of supported motif databases
  my %matrix_db = &RSAT::server::supported_motif_databases();

  ## Identify the selected matrix databases
  foreach my $db (sort keys %matrix_db) {
    my $db_name = $matrix_db{$db}->{name};
    my $format = $matrix_db{$db}->{format};
    my $file = $matrix_db{$db}->{file};


    ## Treat multiple database selections if the DB list was presented with checkboxes
    if ($mode eq "checkbox") {
      if ($query->param("db_selection_".$db_name) =~ /on/i) {
	$matrix_db_params .= " -motif_db ".$db_name." ".$format." ".$ENV{RSAT}."/public_html/motif_databases/".$file;
	push @selected_db, $db_name;
      }

    } elsif ($mode eq "radio") {
      ## Treat single database selection if the DB list was presented with radio box
      if ($query->param('db_choice') eq $db_name) {
	$matrix_db_params .= " -file2 ".$ENV{RSAT}."/public_html/motif_databases/".$file;
	$matrix_db_params .= " -format2 ".$format;
	push @selected_db, $db_name;
      }
    } else {
      &RSAT::error::FatalError($mode, "Invalid choice mode for &GetMatrixDBchoice(). Supported: ".$supported_choice_modes);
    }

  }

#  &RSAT::message::Debug("GetMatrixDBchoice()", scalar(@selected_db)." matrix databases were selected", "parameters=".$matrix_db_params) if ($main::verbose >= 5);
  return($matrix_db_params, @selected_db);
}

##########
### modified by Nga, using select2 javascript library
sub GetMatrixDBchoice_select2 {
    my (%args) = @_;
    my $matrix_db_params ="";
    my @selected_db = ();

    ## Check selection mode
    my $mode = $args{mode} || "checkbox"; ## Display check boxes or radio buttons
    my %supported_choice_mode = ("radio"=>1, "checkbox"=>1);
    my $supported_choice_modes = join ",", sort keys %supported_choice_mode;
    &RSAT::error::FatalError($mode, "Invalid choice mode for &GetMatrixDBchoice(). Supported: ".$supported_choice_modes)
    unless ($supported_choice_mode{$mode});

    ## Load the file containing the description and path of supported motif databases
    my %matrix_db = &RSAT::server::supported_motif_databases();
    my $db_choice_param = ($args{more} == 1) ? "db_choice2" : "db_choice";
    my @motifs = $query->param($db_choice_param);

    ## Identify the selected matrix databases
    foreach my $db (sort keys %matrix_db) {
        my $db_name = $matrix_db{$db}->{name};
        my $format = $matrix_db{$db}->{format};
        my $file = $matrix_db{$db}->{file};


        ## Treat multiple database selections if the DB list was presented with checkboxes
        if ($mode eq "checkbox") {

            #if ($db_name ~~ @motifs) { # avoid experimental ~~, feb2018 Bruno
            if(grep { $db_name eq $_ } @motifs){
                $matrix_db_params .= " -motif_db ".$db_name." ".$format." ".$ENV{RSAT}."/public_html/motif_databases/".$file;
                push @selected_db, $db_name;
            }

        } elsif ($mode eq "radio") {
            ## Treat single database selection if the DB list was presented with radio box
            if ($query->param($db_choice_param) eq $db_name) {
                $matrix_db_params .= " -file2 ".$ENV{RSAT}."/public_html/motif_databases/".$file;
                $matrix_db_params .= " -format2 ".$format;
                push @selected_db, $db_name;
            }
        } else {
            &RSAT::error::FatalError($mode, "Invalid choice mode for &GetMatrixDBchoice(). Supported: ".$supported_choice_modes);
        }

    }

    #  &RSAT::message::Debug("GetMatrixDBchoice()", scalar(@selected_db)." matrix databases were selected", "parameters=".$matrix_db_params) if ($main::verbose >= 5);
    return($matrix_db_params, @selected_db);
}



################################################################
## Save the command string in a temporary file for debugging
sub SaveCommand {
  my ($command, $tmp_file_path) = @_;

  #### temporary file for storing the result
  unless ($tmp_file_path) {
    $tmp_file_path = &RSAT::util::make_temp_file("",$prefix, 1);
  }
  open CMD, ">".$tmp_file_path."_command.txt";
  print CMD $command, "\n";
  close CMD;
}


################################################################
## Save the result in a temporary file on the server this file will be
## deleted after some delay.
##
## Note: this task is now treated in &EmailTheResult().
sub ServerOutput {
    ## redirect the task to email output
    &RSAT::util::EmailTheResult(@_);
}


################################################################
## Run a Web server query and send two notification email (submission
## and completion, respectively), plus display the URL where results
## will become available after completion.
##
## index=>$index_file  index generated by the called program (e.g. compare-matrices)
sub EmailTheResult {
    &RSAT::util::EmailTheResult(@_);
}

=pod

=item B<CheckWebInput()>

Usage: &CheckWebInput($cgi, @fields_to_check);

Check a selected set of fields (specified as @fields_to_check) from a
CGI object (argument $cgi, produced by the Perl module CGI) to detect
potential attacks (e.g. HTML tags).

=cut

sub CheckWebInput {
  my ($cgi, @fields_to_check) = @_;
  my $user_email = $cgi->param('user_email');

  ################################################################
  ## Check if client IP is blacklisted on this server
  &RSAT::server::DetectDeniedIP();

  ################################################################
  ## Detect HTML tags in CGI fields
  @fields_to_check = $query->param unless (scalar(@fields_to_check));
  foreach my $field (@fields_to_check) {
    my $field_contents = $cgi->param($field);

#    &RSAT::message::Debug("Field", $field, "contents", $field_contents) if ($main::verbose >= 10);

    ## Detect HTML tags
    $field_contents =~ s/\s+/ /g; ## make a single-line of the field content
    if ($field_contents =~ /(\<[^\<\>]*\>)/) {
      my $tag = $1;
      &RSAT::server::ReportWebAttack(&ShortFileName($0), "HTML_tag", $tag, $user_email);
      $tag =~ s/</&lt;/g;
      $tag =~ s/>/&gt;/g;
      &RSAT::error::FatalError("Invalid content for field \"$field\"", "<pre>$tag</pre>", "HTML tags are not allowed.");
    }
  }
}


sub SelectFormat {
    my($in_format) = lc($_[0]);

    #### update the sequence format in a web form
    $form =~  s/ selected>Wconsensus/>Wconsensus/i;
    $form =~  s/ selected>Fasta/>Fasta/i;
    $form =~  s/ selected>NCBI/>NCBI/i;
    $form =~  s/ selected>IG/>IG/i;
    $form =~  s/ selected>raw/>raw/i;
    $form =~  s/ selected>multi/>multi/i;
    if ($in_format =~ /fasta/i) {
	$form =~  s/\>Fasta/ SELECTED\>Fasta/i;
    } elsif ($in_format =~ /multi/i) {
	$form =~  s/\>multi/ SELECTED\>multi/i;
    } elsif ($in_format =~ /raw/i) {
	$form =~  s/\>raw/ SELECTED\>raw/i;
    } elsif ($in_format =~ /^wc/i) {
	$form =~  s/\>Wconsensus/ SELECTED\>Wconsensus/i;
    } elsif ($in_format =~ /ig/i) {
	$form =~  s/\>IG/ SELECTED\>IG/i;
    }
}



################################################################
#
# Pipe the result as input for a program requiring sequences
#
sub PipingFormForSequence {
    my ($seq_file, $seq_format, $seq_source) = @_;

    ## A bit tricky: the previous version used the global variable
    ##  $sequence_file.  2015-11-10: JvH adds an argument $seq_file,
    ##  and, if not specified, use the global variable.  Later on I
    ##  should suppress the use of this (and other) global variables).
    if ($seq_file) {
	$sequence_file = $seq_file;
    }
#    my $sequence_url =  &RSAT::util::RelativePath(&RSAT::util::get_pub_temp(), $sequence_file);
    $sequence_url = $sequence_file;
    $sequence_url =~ s|$ENV{RSAT}/public_html|$ENV{rsat_www}|;


    ## Sequence format: can be specified as argument (seq_format) or
    ## as global variable (out_format) for some oldish scripts.
    if ($seq_format) {
	$sequence_format = $seq_format;
    } elsif ($out_format) {
	$sequence_format = $out_format;
    } else {
	$sequence_format = "fasta";
    }

    ## Sequence source is used only for the "visualize" option of
    ## peak-motifs. Options: "none", "galaxy", "getfasta", "bed_coord"
    ## (note: this requires a second file with bed coordinates, which
    ## is not treated by the PipingFormForSequence function).
    unless ($seq_source) {
	$seq_source = "none";
    }


  $oligo_background_model = "<INPUT type=\"hidden\" NAME=\"bg_method\" VALUE=\"background\">";
  $dyad_background_model = "<INPUT type=\"hidden\" NAME=\"bg_method\" VALUE=\"background\">";

    ## Choose organism-specific or alternative background
    if ($query->param('single_multi_org') eq 'multi') {

#	$oligo_background_model = "<INPUT type=\"hidden\" NAME=\"bg_method\" VALUE=\"Residue frequencies from input sequence\">";
#	$dyad_background_model = "<INPUT type=\"hidden\" NAME=\"bg_method\" VALUE=\"monads\">";
      $oligo_background_model .= "<INPUT type=\"hidden\" NAME=\"bg_level\" VALUE=\"taxon\">";
      $oligo_background_model .= "<INPUT type=\"hidden\" NAME=\"taxon\" VALUE=".$query->param('taxon').">";
      $dyad_background_model .= "<INPUT type=\"hidden\" NAME=\"bg_level\" VALUE=\"taxon\">";
      $dyad_background_model .= "<INPUT type=\"hidden\" NAME=\"taxon\" VALUE=".$query->param('taxon').">";
    } else {

      #### choose background model for oligo-analysis
      if ($seq_type =~ /upstream/) {
	if ($noorf) {
	  $background = "upstream-noorf";
	} else {
	  $background = "upstream";
	}
      } elsif ($seq_type =~ /protein/) {
	$background = "protein";
      } else {
	$background = "upstream-noorf";
      }
      $oligo_background_model .= "\n<INPUT type=\"hidden\" NAME=\"background\" VALUE=\"$background\">";
      $dyad_background_model .= "\n<INPUT type=\"hidden\" NAME=\"background\" VALUE=\"$background\">";
    }

print qq|
<HR SIZE = "3" />
<table class = "nextstep">
<tr><td colspan = 5><h3>Next step</h3></td></tr>


<tr valign="top" align="center">

    <th rowspan=2 align=center>
      	<font size=-1>Motif  Discovery<br>(<i>ab initio</i>)</font>
    </th>

    <td align=center>
	<FORM METHOD="POST" ACTION="oligo-analysis_form.cgi">

	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
    <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
        <INPUT type="hidden" NAME="sequence_type" VALUE="$seq_type">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="background" VALUE="$background">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	$oligo_background_model
	<INPUT type="submit" value="oligo-analysis">
	</FORM>
	Over- or under-represented words
    </td>
|;
    if ($seq_type eq "protein") {
      print "</tr>";
    } else {
    print <<End_of_form;
    <td align=center>
	<FORM METHOD="POST" ACTION="dyad-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	$dyad_background_model
	<INPUT type="submit" value="dyad analysis">
	</FORM>
	Overrepresented spaced pairs
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="position-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="hidden" NAME="background" VALUE="$background">
	<INPUT type="submit" value="position analysis">
	</FORM>
	Positionally biased words
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="local-word-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	$oligo_background_model
	<INPUT type="submit" value="local-word-analysis">
	</FORM>
	Windows of word over-representation
    </td>

</tr>

<tr valign="top" align="center">



    <td align=center>
	<FORM METHOD="POST" ACTION="info-gibbs_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="info-gibbs">
	</FORM>
	Gibbs sampling <br>(Defrance, 2009)
    </td>

    <!--td align=center>
	<FORM METHOD="POST" ACTION="gibbs_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="gibbs">
	</FORM>
	Gibbs sampling <br>(Neuwald, 1995)
    </td-->

    <td align=center>
	<FORM METHOD="POST" ACTION="peak-motifs_form.cgi">
	<INPUT type="hidden" NAME="sequence_url1" VALUE="$sequence_url">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="hidden" NAME="visualize" VALUE="$seq_source">
	<INPUT type="submit" value="peak-motifs">
	</FORM>
	<b>Full work flow</b><br>for chip-seq peaks</br>and other seq types
    </td-->

<!--
    <td align=center>
	<FORM METHOD="POST" ACTION="consensus_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="consensus">
	</FORM>
	Greedy algorithm <br>(Hertz, 1990)
    </td>
-->
</tr>

<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	<B>Pattern matching</B><BR>
	(known patterns)
	</font>
    </td>


    <td align=center>
	<FORM METHOD="POST" ACTION="dna-pattern_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="dna-pattern">
	</FORM>
	Regular expressions and IUPAC search.
    </td>

    <td align=center>
        <FORM METHOD="POST" ACTION="matrix-scan-quick_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="matrix-scan-quick (matrices)">
	</FORM>
	Position-specific scoring matrices
    </td>

    <td align=center>
        <FORM METHOD="POST" ACTION="matrix-scan_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="matrix-scan (full options)">
	</FORM>
	Position-specific scoring matrices
    </td>

    <!--td align=center>
	<FORM METHOD="POST" ACTION="patser_form.cgi">
	<INPUT type="hidden" NAME="organism_name" VALUE="$organism_name">
        <INPUT type="hidden" NAME="organism" VALUE="$organism">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="patser (matrices)">
	</FORM>
	Position-specific scoring matrices
    </td-->


    <td align=center>
    &nbsp;
    </td>

    <td align=center>
    &nbsp;
    </td>

</tr>


<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	<B>Utilities</B>
	</font>
    </th>

    <td align=center>
	<FORM METHOD="POST" ACTION="convert-seq_form.cgi">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="convert sequence">
	</FORM>
	Format inter-conversions + mask short fragments.
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="purge-sequence_form.cgi">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
	<INPUT type="submit" value="purge sequence">
	</FORM>
	Mask redundant fragments.
    </td>

    <td align=center>
    &nbsp;
    </td>

    <td align=center>
    &nbsp;
    </td>
</tr>


</table>
End_of_form
    }
}


################################################################
## Background models based on a genome subset
sub PrintGenomeSubsetBgOptions {
  $checked{$default{bg_level}} = "CHECKED";
  $checked{$default{bg_method}} = "CHECKED";

  #### Calibrated on genome subsets
  print( "<br><input type='radio' NAME='bg_method' id='bg_method_background' VALUE='background' $checked{'background'}>");
  print ("<b>Genome subset</b>");

  print ( "&nbsp;&nbsp;<a class='iframe' href='help.oligo-analysis.html#background'>Sequence type</a> &nbsp;&nbsp;&nbsp;&nbsp;",
	  $query->popup_menu(-id=>'background',
			     -name=>'background',
			     -Values=>["upstream",
				       "upstream-noorf",
				       "protein"],
			     -default=>$default{background}));


  print ("<ul>");
  print( "<input type='radio' NAME='bg_level' id='bg_level_organism' VALUE='organism' $checked{organism}>", &OrganismPopUpString('bg_org'=>'1'));


  my $taxon_popup = &TaxonPopUpString("node");
  if ($taxon_popup) {
    print( "<br><input type='radio' NAME='bg_level' id='bg_level_taxon' VALUE='taxon' $checked{taxon}>", $taxon_popup);
  }
  print ("</ul>");


  print "<p>";
}

################################################################
## Background model options for oligo-analysis + ORM
sub PrintOligoBackgroundOptions {
  $checked{$default{bg_method}} = "CHECKED";
  print "<a class='iframe' href='help.oligo-analysis.html#exp_freq'><B>Background model</b></a>&nbsp;";
  &PrintGenomeSubsetBgOptions();

  #### Estimated from the input sequence set

  print ("<br><b>Estimate from input sequence</b>");

  ## Markov model
  print ("<br><input type='radio' NAME='bg_method'  VALUE='Markov model (higher order dependencies)' $checked{'Markov model (higher order dependencies)'}>", "Markov model (higher order dependencies)");

  print "&nbsp;&nbsp;order &nbsp;";
  print $query->textfield(-name=>'markov_order',
			  -default=>$default{markov_order},
			  -size=>5);

  #### Lexicon partitioning
  #print "<br><input type='radio' NAME='bg_method' VALUE='Lexicon partitioning' $checked{'Lexicon partitioning'}>Lexicon partitioning<p>";

  #### Bernouilli model
  #print "<br><input type='radio' NAME='bg_method' VALUE='Residue frequencies from input sequence' $checked{'Residue frequencies from input sequence'}>Residue frequencies from input sequence<p>";

  #### equiprobable residues
  print "<br><input type='radio' NAME='bg_method' VALUE='Equiprobable residues' $checked{'Equiprobable residues'}>Equiprobable residues (<A class='iframe' HREF='help.oligo-analysis.html#equiprobable'>usually NOT recommended</a>)<p>";

#   ## Custom expected frequency file
#   print ("<a href='help.oligo-analysis.html#upload_freq_file'><b>Upload your own expected frequency file</b></a><BR>");
#   print ("<br><input type='radio' NAME='bg_method' VALUE='freq_file_upload' $checked{'freq_file_upload'}>");
#   print ($query->filefield(-name=>'upload_freq_file',-default=>'starting value',-size=>30,-maxlength=>200));
#   print "<p>";

  ## Custom background model file
#  print ("<a href='help.oligo-analysis.html#upload_bgfile'><b>Upload your own background model</b></a><BR>");
#  print ("<br><input type='radio' NAME='bg_method' VALUE='bgfile_upload' $checked{'bgfile_upload'}>");
#  print ($query->filefield(-name=>'upload_bgfile',-default=>'starting value',-size=>30,-maxlength=>200));

  print ("<b>Custom background model</b><br><br>");
  print "&nbsp;&nbsp;<a href=create-background-model_form.cgi><b>Create your own background model</b></a><br/>";
  &DisplayBackgroundFileUpload();
  print "<p>\n";
}


################################################################
## Load default prameters for dyad-analysis form
sub LoadDyadDefault {
  ### default values for filling the form
    #$default{organism} = "Saccharomyces cerevisiae";
  $default{bg_method} = "background";
  $default{background} = "upstream-noorf";
  $default{bg_level} = "organism";
  #$default{title} = "";
  $default{sequence} = "";
  $default{sequence_format} = "fasta";
  $default{sequence_file} = "";
  $default{upload_file} = "";
  $default{oligo_size} = 3;
  $default{spacing_from} = 0;
  $default{spacing_to} = 20;
  $default{strand} = "both strands";
  $default{noov} = 'checked';
  $default{purge} = 'checked';
  $default{dyad_type} = "any dyad";
  $default{exp_freq} = "background";
  $default{upload_freq_file} = "";
  #$default{lth_occ_sig} = "0";
  $default{to_matrix} = '';

  ## Return values and thresholds
  $default{zscore} = '';
  $default{lth_zscore} = 'none';
  $default{uth_zscore} = 'none';

  $default{rank} = 'checked';
  $default{lth_rank} = "none";
  $default{uth_rank} = "none";

  $default{ratio} = '';
  $default{lth_ratio} = "none";
  $default{uth_ratio} = "none";

  $default{occ} = 'checked';
  $default{lth_occ} = "1";
  $default{uth_occ} = "none";

  $default{proba} = 'checked';
  $default{lth_occ_P} = "none";
  $default{uth_occ_P} = "none";

  $default{eval} = 'checked';
  $default{lth_occ_E} = "none";
  $default{uth_occ_E} = "none";

  $default{lth_occ_sig} = "0";
  $default{uth_occ_sig} = "none";

  $default{freq} = '';
  $default{lth_observed_freq} = "none";
  $default{uth_observed_freq} = "none";
}

################################################################
## Print background model optiosn for dyad-analysis
sub PrintDyadBackgroundOptions {
  $checked{$default{bg_method}} = "CHECKED";
  print "<A class='iframe' HREF='help.oligo-analysis.html#exp_freq'><B>Background model</B></A>&nbsp;<p>";

  &PrintGenomeSubsetBgOptions();

  print ( "<input type='radio' NAME='bg_method' VALUE='monads' $checked{monads}>","<b>Monad frequencies from the input sequence</b>");

  print "<BR>\n";

  print ("<a class='iframe' href='help.dyad-analysis.html#upload_freq_file'><b>Upload your own expected frequency file</b></a><BR>");
  print ("<br><input type='radio' NAME='bg_method' VALUE='file_upload' $checked{'file_upload'}>");
  print ($query->filefield(-name=>'upload_freq_file',-default=>'starting value',-size=>30,-maxlength=>200));
  print "<p>";

}


################################################################
## Table with all the return fields and thresholds for dyad-analysis
sub PrintDyadReturnFields {
  my (%args) = @_;
#  print "<p><br>\n";

  print $query->table({-border=>0,-cellpadding=>2,-cellspacing=>0, -bgcolor=>'#FFFFFF'},
		      $query->Tr({-align=>"left",-valign=>"TOP"},
				 [
				  $query->th(["<a class='iframe' href='help.oligo-analysis.html#return_fields'><b>Return fields</b></a>",
					      " <a class='iframe' href='help.oligo-analysis.html#thresholds'>Lower<br>Threshold</a> ",
					      " <a class='iframe' href='help.oligo-analysis.html#thresholds'>Upper<br>Threshold</a> "]),

				  ### occurrences
				  $query->td([$query->checkbox(-name=>'occ',
							       -checked=>$default{occ},
							       -label=>' Occurrences '),
					      $query->textfield(-name=>'lth_occ',
								-default=>$default{lth_occ},
								-size=>5),
					      $query->textfield(-name=>'uth_occ',
								-default=>$default{uth_occ},
								-size=>5)
					     ]),

				  ### binomial proba
				  $query->td([$query->checkbox(-name=>'proba',
							       -checked=>$default{proba},
							       -label=>' Binomial proba '),
					      $query->textfield(-name=>'lth_occ_P',
								-default=>$default{lth_occ_P},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_P',
								-default=>$default{uth_occ_P},
								-size=>5)]),
				  ### binomial E-value
				  $query->td([$query->checkbox(-name=>'eval',
							       -checked=>$default{eval},
							       -label=>' Binomial E-value '),
					      $query->textfield(-name=>'lth_occ_E',
								-default=>$default{lth_occ_E},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_E',
								-default=>$default{uth_occ_E},
								-size=>5),
					     ]),

				  ### significance index
				  $query->td([$query->checkbox(-name=>'proba',
							       -checked=>$default{proba},
							       -label=>' Significance '),
					      $query->textfield(-name=>'lth_occ_sig',
								-default=>$default{lth_occ_sig},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_sig',
								-default=>$default{uth_occ_sig},
								-size=>5)
					     ]),

				  ### Z-scores
				  $query->td([$query->checkbox(-name=>'zscore',
							       -checked=>$default{zscore},
							       -label=>' Z-scores '),
					      $query->textfield(-name=>'lth_zscore',
								-default=>$default{lth_zscore},
								-size=>5),
					      $query->textfield(-name=>'uth_zscore',
								-default=>$default{uth_zscore},
								-size=>5)
					     ]),

				  ### frequencies
				  $query->td([$query->checkbox(-name=>'freq',
							       -checked=>$default{freq},
							       -label=>' Frequencies '),
					      $query->textfield(-name=>'lth_observed_freq',
								-default=>$default{lth_observed_freq},
								-size=>5),
					      $query->textfield(-name=>'uth_observed_freq',
								-default=>$default{uth_observed_freq},
								-size=>5)
					     ]),


				  ### ratio
				  $query->td([$query->checkbox(-name=>'ratio',
							       -checked=>$default{ratio},
							       -label=>' Obs/exp ratio '),
					      $query->textfield(-name=>'lth_ratio',
								-default=>$default{lth_ratio},
								-size=>5),
					      $query->textfield(-name=>'uth_ratio',
								-default=>$default{uth_ratio},
								-size=>5)
					     ]),

				  ### rank
				  $query->td([$query->checkbox(-name=>'rank',
							       -checked=>$default{rank},
							       -label=>' Rank '),
					      $query->textfield(-name=>'lth_rank',
								-default=>$default{lth_rank},
								-size=>5),
					      $query->textfield(-name=>'uth_rank',
								-default=>$default{uth_rank},
								-size=>5)
					     ]),

				 ]
				)
		     );

  #### Convert patterns to matrix
  unless ($args{no_matrix}) {
    print $query->checkbox(-name=>'to_matrix',
			   -checked=>$default{to_matrix},
			   -label=>'');
    print "&nbsp;Convert assembled patterns to Position-Specific Scoring Matrices (<font color=red>Can be time-consuming</font>)";
    print "<BR>";
  }
}

################################################################
## Default parameters for matrix-from-patterns
## (shared by dyad-analysis and oligo-analysis Web interfaces)
sub MatrixFromPatterns_defaults {
  $default{to_matrix} = 1;
  $default{flanks} = 2;
  $default{max_asmb_nb} = 10;
  $default{min_weight} = 5;
  $default{clustering} = 'none';
}

################################################################
## Print the options for converting assembled patterns into matrices
## (PSSM)
sub MatrixFromPatterns_print_form {
  print $query->checkbox(-name=>'to_matrix',
			 -checked=>$default{to_matrix},
			 -label=>'');
  print "&nbsp;Convert assembled patterns to matrices.";

#   ## Mean sites per sequences (only valid with -collect_method info-gibbs)
#   print "&nbsp;"x4, "Mean sites per sequence";
#   print $query->textfield(-name=>'gibbs_msps',
# 			  -default=>$default{gibbs_msps},
# 			  -size=>3);

#   ## Gibbs iterations (only valid with -collect_method info-gibbs)
#   print "&nbsp;"x4, "Iterations";
#   print $query->textfield(-name=>'gibbs_iter',
# 			  -default=>$default{gibbs_iter},
# 			  -size=>3);

  
  ## Max number of matrices
  print "<br>\n";
  print "&nbsp;"x12, "Max pattern assemblies";
  print $query->textfield(-name=>'max_asmb_nb',
			  -default=>$default{max_asmb_nb},
			  -size=>2);

  ## Minimal weight score
  print "&nbsp;"x4, "Min site weight";
  print $query->textfield(-name=>'min_weight',
			  -default=>$default{min_weight},
			  -size=>3);

  ## Flanking residues
  print "&nbsp;"x4, "Flanking residues";
  print $query->textfield(-name=>'flanks',
			  -default=>$default{flanks},
			  -size=>2);

  # ## Matrix format
  print "&nbsp;"x4, "Matrix clustering&nbsp;\n";
  print $query->popup_menu(-id=>'clustering', 
  			   -name=>'clustering',
  			   -Values=>['sig',
  				     'counts',
  				     'both',
  				     'none'],
  			   -default=>$default{clustering});

  
}

################################################################
## Run matrix-from-patterns and display the result on the Web page
sub MatrixFromPatterns_run {
  my $pssm_prefix = $tmp_file_path."_pssm";
  my $sig_matrix_file = $pssm_prefix."_sig_matrices.tf";
  my $rescaled_sig_matrix_file = $pssm_prefix."_sig_matrices_rescaled.tf";
#  my $sig_matrix_file_nr = $pssm_prefix."_sig_matrices_nr_cluster_root_motifs.tf";
#  $gibbs_matrix_file = $pssm_prefix."_gibbs_matrices.txt";
  $pssm_file_tab = $pssm_prefix."_count_matrices.txt"; ## has to be global for the piping form
  $pssm_file_tf = $pssm_prefix."_count_matrices.tf"; ## has to be global for the piping form

  ## Generate the command to extract matrices from patterns
#  $pssm_command = $SCRIPTS."/matrix-from-patterns";
  $pssm_command = &RSAT::server::GetProgramPath("matrix-from-patterns");
  $pssm_command .= " -v 1";
  $pssm_command .= " -logo ";
  #  $pssm_command .= " ".$str;
  $pssm_command .= " -seq ".$sequence_file;
  $pssm_command .= " -format $sequence_format";
  $pssm_command .= " -asmb ".$assembly_file;
  #  $pssm_command .= " -gibbs_msps ".$query->param('gibbs_msps');
  #  $pssm_command .= " -g<ibbs_iter ".$query->param('gibbs_iter');
  $pssm_command .= " -min_weight ".$query->param('min_weight');
  $pssm_command .= " -flanks ".$query->param('flanks');
  $pssm_command .= " -max_asmb_nb ".$query->param('max_asmb_nb');
  if ($query->param('clustering')) {
    $pssm_command .= " -cluster_".$query->param('clustering');
  }
  #	  $pssm_command .= " -gibbs_final" if ($query->param('gibbs_final'));
  $pssm_command .= " -uth Pval 0.00025";
  $pssm_command .= " -bginput -markov 0";
  $pssm_command .= " -o ".$pssm_prefix;

  ## Run the command
  print "<hr /><pre><b>Command to generate matrices (PSSM):</b> ", &RSAT::util::hide_RSAT_path($pssm_command), "\n</pre>" if ($ENV{rsat_echo} >= 0);
  system("$pssm_command");
  push @result_files, ('Significance matrices', $sig_matrix_file);
  push @result_files, ('Rescaled significance matrices', $rescaled_sig_matrix_file);
#  push @result_files, ('Non-redundant matrices', $sig_matrix_file_nr);
  #  push @result_files, ('info-gibbs matrices', $gibbs_matrix_file);
  push @result_files, ('Final matrices (transfac format)', $pssm_file_tf);
  push @result_files, ('Final matrices (tab format)', $pssm_file_tab);

  my ($out_matrix_file) = &display_matrices_web($pssm_file_tab, "tab", 0);
  return ($out_matrix_file);
}

################################################################
## Generate a form for piping the results of oligo-analysis and
## dyad-analysis to various programs.
sub OligoDyadPipingForm {

    #### title
    $title = $query->param('title');
    $title =~ s/\"/\'/g;

    #### strand for pattern-assembly
    if ($query->param('strand') =~ /single/) {
	$strand_opt .= " sensitive";
    } else {
	$strand_opt .= " insensitive";
    }

    ## matrix scanning and conversion
    if ($query->param('to_matrix')) {

      ## Prepare form for sending matrices and sequences to matrix-scan
      $to_matrix_scan = "<td valign=bottom align=center>";
      $to_matrix_scan .= "<FORM METHOD='POST' ACTION='matrix-scan_form.cgi'>";
      $to_matrix_scan .= "<INPUT type='hidden' NAME='matrix_file' VALUE='".$pssm_file_tf."'>";
      $to_matrix_scan .= "<INPUT type='hidden' NAME='matrix_format' VALUE='transfac'>";
      $to_matrix_scan .= "<INPUT type='hidden' NAME='sequence_file' VALUE='$sequence_file'>";
      $to_matrix_scan .= "<INPUT type='hidden' NAME='sequence_format' VALUE='$sequence_format'>";
      $to_matrix_scan .= "<INPUT type='submit' value='matrix-based pattern matching (matrix-scan)'>";
      $to_matrix_scan .= "</FORM>";
      $to_matrix_scan .= "</td>";

      ## Prepare form for sending matrices to convert-matrix
      $to_convert_matrix = "<td valign=bottom align=center>";
      $to_convert_matrix .= "<FORM METHOD='POST' ACTION='convert-matrix_form.cgi'>";
      $to_convert_matrix .= "<INPUT type='hidden' NAME='matrix_file' VALUE='".$pssm_file_tf."'>";
      $to_convert_matrix .= "<INPUT type='hidden' NAME='matrix_format' VALUE='transfac'>";
      $to_convert_matrix .= "<INPUT type='submit' value='matrix conversion'>";
      $to_convert_matrix .= "</FORM>";
      $to_convert_matrix .= "</td>";

      $matrix_treatment = join ("<tr>", $to_matrix_scan, $to_convert_matrix, "</tr>");
    }

  print <<End_of_form;
<hr size = "3"><table CLASS = "nextstep" CELLSPACING=0 CELLPADDING=10 BORDER=0 NOWRAP>
<tr>

<tr VALIGN="top" ALIGN="center">
    <Th VALIGN=BOTTOM ALIGN=CENTER COLSPAN=6>
	Next step
    </Th>

</tr>

<td valign=bottom align=center>
<FORM METHOD="POST" ACTION="dna-pattern_form.cgi">
<INPUT type="hidden" NAME="title" VALUE="$title">
<INPUT type="hidden" NAME="pattern_file" VALUE="$result_file">
<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
<INPUT type="hidden" NAME="sequence_format" VALUE="$sequence_format">
<INPUT type="submit" value="string-based pattern matching (dna-pattern)">
</FORM>
</td>

<td valign=bottom align=center>
<FORM METHOD="POST" ACTION="pattern-assembly_form.cgi">
<INPUT type="hidden" NAME="local_pattern_file" VALUE="$result_file">
<INPUT type="hidden" NAME="subst" VALUE=1>
<INPUT type="hidden" NAME="maxfl" VALUE=1>
<INPUT type="hidden" NAME="sc" VALUE="auto">
<INPUT type="hidden" NAME="strand" VALUE=$strand_opt>
<INPUT type="submit" value="pattern assembly">
</FORM>
</td>
</tr>

$matrix_treatment

<tr>
<td valign=bottom align=center>
<FORM METHOD="POST" ACTION="XYgraph_form.cgi">
<INPUT type="hidden" NAME="title1" VALUE="oligo-analysis result">
<INPUT type="hidden" NAME="title2" VALUE="$title">
<INPUT type="hidden" NAME="XYgraph_file" VALUE="$result_file">
<INPUT type="hidden" NAME="xcol" VALUE="5">
<INPUT type="hidden" NAME="xleg1" VALUE="expected occurrences">
<INPUT type="hidden" NAME="ycol" VALUE="4">
<INPUT type="hidden" NAME="yleg1" VALUE="observed occurrences">
<INPUT type="submit" VALUE="XY graph">
</FORM>
</td>

  <td>
<FORM METHOD='POST' ACTION='classfreq_form.cgi'>
<INPUT type='hidden' NAME='transferred_file' VALUE='$result_file'>
<INPUT type='submit' VALUE='Frequency distribution'>
 </form>
  </td>
</tr>

</tr>
</table>
End_of_form

}


################################################################
## Display one or several PSSM on a Web page
##
## Usage:
##   my ($out_matrix_file) = &display_matrices_web($in_matrix_file, $in_format, $no_convert);
sub display_matrices_web {
  my ($in_matrix_file, $in_format, $no_convert, $logo_dir) = @_;

  my $public_temp_dir = &RSAT::util::get_pub_temp();
  print "\n<hr/>\n";

  &RSAT::error::FatalError("missing input matrix file for display_matices_web()") unless ($in_matrix_file);
  &RSAT::error::FatalError("missing input matrix format for display_matices_web()") unless ($in_format);

  my $matrix_prefix = &ShortFileName($in_matrix_file);
  $matrix_prefix .= s/\.${in_format}$//;
  my $out_matrix_file;

  if ($no_convert) {
    $out_matrix_file = $in_matrix_file;
  } else {
    $out_matrix_file = &RSAT::util::make_temp_file("",$matrix_prefix, 1);
    $out_matrix_file .= "_converted.tab";
    unless ($logo_dir) {
      #    $logo_dir = $ENV{RSAT}."/public_html/tmp";
      ($out_matrix_dir, $out_matrix_filename) = &SplitFileName($out_matrix_file);
      $logo_dir = $out_matrix_dir."/logos";
      system("mkdir -p $logo_dir");
    }

    my $cmd = "$ENV{RSAT}/perl-scripts/convert-matrix -v 1 ";
    $cmd .= " -i ".$in_matrix_file;
    $cmd .= " -from ".$in_format;
    $cmd .= " -to tab ";
    $cmd .= " -return counts";
    $cmd .= " -return consensus";
    #  $cmd .= " -return parameters";
    ## Logo parameters

    ## JvH TEMPORARILY DISACTIVATED pdf logos (201502-05) to
    ## circumvent strange bug with ghostscript on rsat.ulb.ac.be
    $cmd .= " -return logo -logo_format png ";
#    $cmd .= " -return logo -logo_format png,pdf ";
    $cmd .= " -logo_opt '-e' "; ## Error bar
    $cmd .= " -logo_opt '-M' "; ## Small sample correction
    $cmd .= " -logo_dir ".$logo_dir;
    $cmd .= " -o ".$out_matrix_file;
    print "<pre><b>Matrix conversion command:</b> ", &RSAT::util::hide_RSAT_path($cmd), "\n</pre>" if ($ENV{rsat_echo} >= 1);
    system ($cmd);

    &DelayedRemoval($out_matrix_file);
  }

  ### Print result on the web page
  print '<h2>Matrices</h2>';
  print "<pre>";
#  print `cat $out_matrix_file`;
  my ($res) = &OpenInputFile($out_matrix_file);
  while (<$res>) {
    next if ($_ =~ /logo file:(.*)\.pdf$/);
    if ($_ =~ /logo file:(.*)\.png$/){
      (local $logo = $1 )=~ s|${public_temp_dir}| ${WWW_TMP}|g;
      $logo =~ s/\.png//;
      ## JvH TEMPORARILY DISACTIVATED pdf logos (201502-05) to
      ## circumvent strange bug with ghostscript on rsat.ulb.ac.be
      print "<a href = '".$logo.".png'><img src='".$logo.".png' height='120' /></a>";
#      print "<a href = '".$logo.".pdf'><IMG SRC='".$logo.".png' height='120'></a>";

      ## A trick to print the carriage return only after the second logo (reverse complement)
      if ($after_logo) {
	print "\n";
      }
      $after_logo = 1;
    } else {
      $after_logo = 0;
#      s|$ENV{RSAT}/||g;
      print &RSAT::util::hide_RSAT_path($_);
    }
  }
  close ($res);
  print "</pre>";

  return ($out_matrix_file);
}

################################################################
## Print a HTML table with links to one or several result files
##
## Usage:
## &PrintResultURL(tab=>result_file.tab,html=>result_file.html, ...);
sub PrintURLTable {
  my (@files) = @_;
  print "<h2>Result file(s)</h2>";
  print "<table class=\"resultlink\">\n";
  print "<tr><th>Content</th>";
  print "<th>URL</th></tr>";
  while (my $type = shift @files) {
    my $file = shift @files;
#    $file = &ShortFileName($file);
    my $result_URL = $ENV{rsat_www}."/tmp/";
    $result_URL .= &RSAT::util::RelativePath(&RSAT::util::get_pub_temp(), $file);
    print ("<tr>","<td>".$type."</td>","<td>","<a href='".$result_URL."'>".$result_URL."</a>","</td>","</tr>");
  }
  print "</table>";
}

###############################################################
## Check whether compara is supported on this server
sub check_compara_tools() {
    if ($ENV{compara_tools} == 0) {
    print "<font size=+1>\n";
    print "<p><font color='red'>Compara is not supported on this instance of RSAT.</font></p>\n";
    print "<p>It is currently supported on the following RSAT servers: </p>\n";
    print "<ol>\n";
    print "<li>Plants: <a target='_top' href='http://plants.rsat.eu/'>http://plants.rsat.eu/</a></li>";
    print "</ol>\n";
    print "</font>\n";
    print "</hr>";
    print $query->end_html;
    exit(0);
    }
}


################################################################
## &CheckPhyloSupported()
##
## Check if phylogenetic footprint approaches are supported on this
## instance of RSAT.
sub check_phylo_tools() {
    if ($ENV{phylo_tools} == 0) {
	print "<font size=+1>\n";
	print "<p><font color='red'>Phylogenetic tools are not supported on this instance of RSAT.</font></p>\n";
	print "Our tools for phylogenetic footprinting (footprint-discovery, footprint-scan) are particularly well suited for microbial genomes (small genomes, many species available), but give poor results with multicellular organisms.</p>";
	print "<p>Phylogenetic approaches are currently supported on the following RSAT servers: </p>\n";
	print "<ol>\n";
	print "<li>Prokaryotes: <a target='_top' href='http://prokaryotes.rsat.eu/'>http://prokaryotes.rsat.eu/</a></li>";
	print "<li>Fungi: <a target='_top' href='http://fungi.rsat.eu/'>http://fungi.rsat.eu/</a></li>";
	print "</ol>\n";
	print "</font>\n";
	print "</hr>";
	print $query->end_html;
	exit(0);
    }
}

################################################################
## &CheckProkaryotServer()
##
## Check if phylogenetic footprint approaches are supported on this
## instance of RSAT.
sub check_prokaryote_server() {
    if ($ENV{prokaryote_server} == 1) {
	print "<p><font color='red'>Genomes in the RSAT Prokaryotes server were recently re-installed.</font> \n";
	print "Genome names now follow the NCBI standard to easily identify assemblies, if you cannot find your genome please check this naming list to find the correct ID: <a target='_top' href='http://prokaryotes.rsat.eu/data/genomes/RSAT_NCBI_ID_genomes.html'>Genome IDs list</a></p>";
	#exit(0);
    }
}

=pod


=item B<check_ensembl_tools>

Check with the environment variables (loaded from RSAT_config.props)
if this RSAT instance supports ensembl tools. If not exit with an
error message.

=cut
sub check_ensembl_tools {
  if ($ENV{ensembl_tools} == 0){
    &RSAT::message::Warning("Sorry, this RSAT instance does not support retrieve-ensembl-seq.");
    &RSAT::message::Info("Ensembl is essentially oriented towards Metazoa, so retrieve-ensembl-seq is available on <a target='_blank' href='http://metazoa.rsat.eu/'>http://metazoa.rsat.eu/</a>.");
    print $query->end_html;
    exit(0);
  }
  return();
}

=pod

=item B<check_variation_tools>

Check with the environment variables (loaded from RSAT_config.props)
if this RSAT instance supports variation tools. If not exit with an
error message.

=cut
sub check_variation_tools {
  if ($ENV{variations_tools} == 0){
    &RSAT::message::Warning("Sorry, this RSAT instance does not support the analysis of regulatory variations");
    &RSAT::message::Info("Variations are supported for Metazoa on <a target='_blank' href='http://metazoa.rsat.eu/'>http://metazoa.rsat.eu/</a>.");
    print $query->end_html;
    exit(0);
  }
  return();
}

1; # return true
